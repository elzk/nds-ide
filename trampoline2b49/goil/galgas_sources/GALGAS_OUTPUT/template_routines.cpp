//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'template_routines.cpp'                        *
//                        Generated by version 2.0.0                         *
//                       july 7th, 2010, at 17h15'58"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if CURRENT_LIBPM_VERSION != 820
  #error "This file has been compiled with a version of GALGAS that uses libpm version 820, different than the current version (CURRENT_LIBPM_VERSION) of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "template_routines.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "template_routines.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                Implementation of function "goil_template"                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string function_goil_template (C_Compiler & inLexique,
                                const GGS_string  var_cas_prefix,
                                const GGS_goilTemplateVariableMap   var_cas_cfg,
                                const GGS_string  var_cas_name COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_goil_template at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_result ;
  var_cas_result = GGS_string ("") ;
  GGS_bool automatic_var_429_0 ;
  ::routine_goilTemplateInvocation (inLexique,  GGS_lstring ::constructor_new (inLexique, var_cas_name, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (13)),  var_cas_prefix,  GGS_string ("templates"),  function_rootTemplatesDirectory (inLexique COMMA_SOURCE_FILE_AT_LINE (16)),  GGS_bool (true),  var_cas_cfg,  var_cas_result,  automatic_var_429_0 COMMA_SOURCE_FILE_AT_LINE (12)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_goil_template\n") ;
  #endif
  return var_cas_result ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_goil_template (C_Compiler & inLexique,
                           const GGS_objectlist & inEffectiveParameterArray,
                           const GGS_location & inErrorLocation
                           COMMA_LOCATION_ARGS) {
  const GGS_string arg_0 = GGS_string::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (0) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_goilTemplateVariableMap  arg_1 = GGS_goilTemplateVariableMap ::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (1) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_string arg_2 = GGS_string::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (2) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_string result = function_goil_template (inLexique,
                            arg_0,
                            arg_1,
                            arg_2
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

static const C_galgas_type_descriptorEX *
kArgumentTypeList_goil_template [3] = {& kTypeDescriptor_GGS_string,
                              & kTypeDescriptor_GGS_goilTemplateVariableMap ,
                              & kTypeDescriptor_GGS_string} ;

const C_galgas_function_descriptorEX
kFunction_descriptor_goil_template ("goil_template",
                              functionForGenericCall_goil_template,
                              & kTypeDescriptor_GGS_string,
                              3,
                              kArgumentTypeList_goil_template) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               Implementation of function "computeTemplate"                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string function_computeTemplate (C_Compiler & inLexique,
                                const GGS_string  var_cas_prefix,
                                const GGS_goilTemplateVariableMap   var_cas_cfg,
                                const GGS_string  var_cas_name COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_computeTemplate at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_result ;
  var_cas_result = GGS_string ("") ;
  GGS_bool automatic_var_731_0 ;
  ::routine_goilTemplateInvocation (inLexique,  GGS_lstring ::constructor_new (inLexique, var_cas_name, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (31)),  var_cas_prefix,  GGS_string ("templates"),  function_rootTemplatesDirectory (inLexique COMMA_SOURCE_FILE_AT_LINE (34)),  GGS_bool (true),  var_cas_cfg,  var_cas_result,  automatic_var_731_0 COMMA_SOURCE_FILE_AT_LINE (30)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_computeTemplate\n") ;
  #endif
  return var_cas_result ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_computeTemplate (C_Compiler & inLexique,
                           const GGS_objectlist & inEffectiveParameterArray,
                           const GGS_location & inErrorLocation
                           COMMA_LOCATION_ARGS) {
  const GGS_string arg_0 = GGS_string::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (0) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_goilTemplateVariableMap  arg_1 = GGS_goilTemplateVariableMap ::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (1) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_string arg_2 = GGS_string::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (2) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_string result = function_computeTemplate (inLexique,
                            arg_0,
                            arg_1,
                            arg_2
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

static const C_galgas_type_descriptorEX *
kArgumentTypeList_computeTemplate [3] = {& kTypeDescriptor_GGS_string,
                              & kTypeDescriptor_GGS_goilTemplateVariableMap ,
                              & kTypeDescriptor_GGS_string} ;

const C_galgas_function_descriptorEX
kFunction_descriptor_computeTemplate ("computeTemplate",
                              functionForGenericCall_computeTemplate,
                              & kTypeDescriptor_GGS_string,
                              3,
                              kArgumentTypeList_computeTemplate) ;

//---------------------------------------------------------------------------*

