//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'goil_basic_types.cpp'                         *
//                        Generated by version 2.0.0                         *
//                       july 7th, 2010, at 17h16'7"                         *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if CURRENT_LIBPM_VERSION != 820
  #error "This file has been compiled with a version of GALGAS that uses libpm version 820, different than the current version (CURRENT_LIBPM_VERSION) of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "goil_basic_types.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "goil_basic_types.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_basic_type'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_basic_type::
cPtr_basic_type (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
location (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_basic_type * GGS_basic_type::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_basic_type) ;
    return (cPtr_basic_type *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_basic_type::
method_string (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_s COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_s = GGS_string ("") ;
}

//---------------------------------------------------------------------------*

void cPtr_basic_type::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@basic_type:"
           << location.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_basic_type::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_basic_type::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_basic_type (& typeid (cPtr_basic_type), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_basic_type::galgasRTTI (void) const {
  return & gClassInfoFor__basic_type ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_basic_type'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_basic_type ("basic_type", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_basic_type::
GGS_basic_type (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_basic_type::
GGS_basic_type (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_basic_type GGS_basic_type::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_basic_type result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_basic_type *> (inPointer) != NULL)
      : (typeid (cPtr_basic_type) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_basic_type (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_basic_type),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_basic_type::
reader_location (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_basic_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_basic_type *) mPointer)->location ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_basic_type::actualTypeName (void) const {
  return "basic_type" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_basic_type::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__basic_type ("basic_type", & kTypeDescriptor_GGS_basic_type) ;

//---------------------------------------------------------------------------*

GGS_object GGS_basic_type::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_basic_type * p = NULL ;
    macroMyNew (p, GGS_basic_type (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_basic_type GGS_basic_type::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_basic_type result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_basic_type * p = dynamic_cast <const GGS_basic_type *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_basic_type, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_basic_type::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_basic_type ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'cPtr_void'                              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_void::
cPtr_void (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_basic_type (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_void * GGS_void::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_void) ;
    return (cPtr_void *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_void::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_void * ptr = dynamic_cast <const cPtr_void *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_void::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@void:"
           << location.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_void::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_void::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_void (& typeid (cPtr_void), & typeid (cPtr_basic_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_void::galgasRTTI (void) const {
  return & gClassInfoFor__void ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_void::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_void (location COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         GALGAS class 'GGS_void'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_void ("void", true, & kTypeDescriptor_GGS_basic_type) ;

//---------------------------------------------------------------------------*

GGS_void::
GGS_void (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_void::
GGS_void (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_void GGS_void::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_void result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_void *> (inPointer) != NULL)
      : (typeid (cPtr_void) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_void (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_void),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void GGS_void::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_void result ;
  macroMyNew (result.mPointer, cPtr_void (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_void::actualTypeName (void) const {
  return "void" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__void ("void", gClassInfoFor__basic_type, & kTypeDescriptor_GGS_void) ;

//---------------------------------------------------------------------------*

GGS_object GGS_void::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_void * p = NULL ;
    macroMyNew (p, GGS_void (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void GGS_void::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_void result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_void * p = dynamic_cast <const GGS_void *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_void, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_void::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_void ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_uint32_class'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint32_class::
cPtr_uint32_class (const GGS_location & argument_0,
                                const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_basic_type (argument_0 COMMA_THERE),
value (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint32_class * GGS_uint32_class::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_uint32_class) ;
    return (cPtr_uint32_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uint32_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_uint32_class * ptr = dynamic_cast <const cPtr_uint32_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_uint32_class::
method_string (C_Compiler & inLexique,
                                GGS_string& var_cas_s COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_s = value.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (40)) ;
}

//---------------------------------------------------------------------------*

void cPtr_uint32_class::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@uint32_class:"
           << location.reader_description (inIndentation + 1)
           << value.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uint32_class::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uint32_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uint32_class (& typeid (cPtr_uint32_class), & typeid (cPtr_basic_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_uint32_class::galgasRTTI (void) const {
  return & gClassInfoFor__uint32_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_uint32_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_uint32_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_uint32_class'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_uint32_class ("uint32_class", true, & kTypeDescriptor_GGS_basic_type) ;

//---------------------------------------------------------------------------*

GGS_uint32_class::
GGS_uint32_class (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uint32_class::
GGS_uint32_class (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uint32_class GGS_uint32_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uint32_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uint32_class *> (inPointer) != NULL)
      : (typeid (cPtr_uint32_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uint32_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uint32_class),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint32_class GGS_uint32_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_uint32_class result ;
  macroMyNew (result.mPointer, cPtr_uint32_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_uint32_class::
reader_value (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint32_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_uint32_class *) mPointer)->value ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uint32_class::actualTypeName (void) const {
  return "uint32_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__uint32_class ("uint32_class", gClassInfoFor__basic_type, & kTypeDescriptor_GGS_uint32_class) ;

//---------------------------------------------------------------------------*

GGS_object GGS_uint32_class::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_uint32_class * p = NULL ;
    macroMyNew (p, GGS_uint32_class (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint32_class GGS_uint32_class::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_uint32_class result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_uint32_class * p = dynamic_cast <const GGS_uint32_class *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_uint32_class, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_uint32_class::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_uint32_class ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Implementation of function "uint32_or_error"                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint  function_uint32_or_error (C_Compiler & inLexique,
                                GGS_basic_type   var_cas_t,
                                GGS_string  var_cas_att COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_uint32_or_error at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_uint  var_cas_v ;
  var_cas_v = GGS_uint (0U) ;
  { const GGS_basic_type _var_1011 = var_cas_t ; // CAST instruction
    if (_var_1011.getPtr () != NULL) {
      macroValidPointer (_var_1011.getPtr ()) ;
      if (typeid (cPtr_uint32_class) == typeid (* (_var_1011.getPtr ()))) {
        const GGS_uint32_class var_cas_ui (_var_1011.getPtr ()) ;
        var_cas_v = var_cas_ui.reader_value (inLexique COMMA_SOURCE_FILE_AT_LINE (52)) ;
      }else{
        var_cas_t.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (54)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (var_cas_att).operator_concat (GGS_string (" is not defined")) COMMA_SOURCE_FILE_AT_LINE (55)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_uint32_or_error\n") ;
  #endif
  return var_cas_v ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_uint32_or_error (C_Compiler & inLexique,
                           const GGS_objectlist & inEffectiveParameterArray,
                           const GGS_location & inErrorLocation
                           COMMA_LOCATION_ARGS) {
  const GGS_basic_type  arg_0 = GGS_basic_type ::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (0) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_string arg_1 = GGS_string::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (1) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_uint  result = function_uint32_or_error (inLexique,
                            arg_0,
                            arg_1
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

static const C_galgas_type_descriptorEX *
kArgumentTypeList_uint32_or_error [2] = {& kTypeDescriptor_GGS_basic_type ,
                              & kTypeDescriptor_GGS_string} ;

const C_galgas_function_descriptorEX
kFunction_descriptor_uint32_or_error ("uint32_or_error",
                              functionForGenericCall_uint32_or_error,
                              & kTypeDescriptor_GGS_uint ,
                              2,
                              kArgumentTypeList_uint32_or_error) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_sint32_class'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sint32_class::
cPtr_sint32_class (const GGS_location & argument_0,
                                const GGS_sint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_basic_type (argument_0 COMMA_THERE),
value (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sint32_class * GGS_sint32_class::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_sint32_class) ;
    return (cPtr_sint32_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sint32_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sint32_class * ptr = dynamic_cast <const cPtr_sint32_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sint32_class::
method_string (C_Compiler & inLexique,
                                GGS_string& var_cas_s COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_s = value.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (61)) ;
}

//---------------------------------------------------------------------------*

void cPtr_sint32_class::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sint32_class:"
           << location.reader_description (inIndentation + 1)
           << value.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sint32_class::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sint32_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sint32_class (& typeid (cPtr_sint32_class), & typeid (cPtr_basic_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sint32_class::galgasRTTI (void) const {
  return & gClassInfoFor__sint32_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sint32_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sint32_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_sint32_class'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sint32_class ("sint32_class", true, & kTypeDescriptor_GGS_basic_type) ;

//---------------------------------------------------------------------------*

GGS_sint32_class::
GGS_sint32_class (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sint32_class::
GGS_sint32_class (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sint32_class GGS_sint32_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sint32_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sint32_class *> (inPointer) != NULL)
      : (typeid (cPtr_sint32_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sint32_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sint32_class),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint32_class GGS_sint32_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_sint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_sint32_class result ;
  macroMyNew (result.mPointer, cPtr_sint32_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint  GGS_sint32_class::
reader_value (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint32_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sint32_class *) mPointer)->value ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sint32_class::actualTypeName (void) const {
  return "sint32_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sint32_class ("sint32_class", gClassInfoFor__basic_type, & kTypeDescriptor_GGS_sint32_class) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sint32_class::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sint32_class * p = NULL ;
    macroMyNew (p, GGS_sint32_class (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint32_class GGS_sint32_class::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sint32_class result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sint32_class * p = dynamic_cast <const GGS_sint32_class *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sint32_class, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sint32_class::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sint32_class ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_uint64_class'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint64_class::
cPtr_uint64_class (const GGS_location & argument_0,
                                const GGS_uint64 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_basic_type (argument_0 COMMA_THERE),
value (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint64_class * GGS_uint64_class::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_uint64_class) ;
    return (cPtr_uint64_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uint64_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_uint64_class * ptr = dynamic_cast <const cPtr_uint64_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_uint64_class::
method_string (C_Compiler & inLexique,
                                GGS_string& var_cas_s COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_s = value.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (68)) ;
}

//---------------------------------------------------------------------------*

void cPtr_uint64_class::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@uint64_class:"
           << location.reader_description (inIndentation + 1)
           << value.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uint64_class::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uint64_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uint64_class (& typeid (cPtr_uint64_class), & typeid (cPtr_basic_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_uint64_class::galgasRTTI (void) const {
  return & gClassInfoFor__uint64_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_uint64_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_uint64_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_uint64_class'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_uint64_class ("uint64_class", true, & kTypeDescriptor_GGS_basic_type) ;

//---------------------------------------------------------------------------*

GGS_uint64_class::
GGS_uint64_class (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uint64_class::
GGS_uint64_class (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uint64_class GGS_uint64_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uint64_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uint64_class *> (inPointer) != NULL)
      : (typeid (cPtr_uint64_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uint64_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uint64_class),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64_class GGS_uint64_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_uint64 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_uint64_class result ;
  macroMyNew (result.mPointer, cPtr_uint64_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64  GGS_uint64_class::
reader_value (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint64_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_uint64_class *) mPointer)->value ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uint64_class::actualTypeName (void) const {
  return "uint64_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__uint64_class ("uint64_class", gClassInfoFor__basic_type, & kTypeDescriptor_GGS_uint64_class) ;

//---------------------------------------------------------------------------*

GGS_object GGS_uint64_class::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_uint64_class * p = NULL ;
    macroMyNew (p, GGS_uint64_class (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64_class GGS_uint64_class::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_uint64_class result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_uint64_class * p = dynamic_cast <const GGS_uint64_class *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_uint64_class, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_uint64_class::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_uint64_class ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Implementation of function "uint64OrError"                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_uint64  function_uint64OrError (C_Compiler & inLexique,
                                GGS_basic_type   var_cas_t,
                                GGS_string  var_cas_att COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_uint64OrError at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_uint64  var_cas_v ;
  var_cas_v = GGS_uint64 (0ULL) ;
  { const GGS_basic_type _var_1557 = var_cas_t ; // CAST instruction
    if (_var_1557.getPtr () != NULL) {
      macroValidPointer (_var_1557.getPtr ()) ;
      if (typeid (cPtr_uint64_class) == typeid (* (_var_1557.getPtr ()))) {
        const GGS_uint64_class var_cas_ui (_var_1557.getPtr ()) ;
        var_cas_v = var_cas_ui.reader_value (inLexique COMMA_SOURCE_FILE_AT_LINE (80)) ;
      }else{
        var_cas_t.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (82)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("Internal error, ")).operator_concat (var_cas_att)).operator_concat (GGS_string (" has a wrong datatype")) COMMA_SOURCE_FILE_AT_LINE (83)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_uint64OrError\n") ;
  #endif
  return var_cas_v ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_uint64OrError (C_Compiler & inLexique,
                           const GGS_objectlist & inEffectiveParameterArray,
                           const GGS_location & inErrorLocation
                           COMMA_LOCATION_ARGS) {
  const GGS_basic_type  arg_0 = GGS_basic_type ::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (0) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_string arg_1 = GGS_string::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (1) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_uint64  result = function_uint64OrError (inLexique,
                            arg_0,
                            arg_1
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

static const C_galgas_type_descriptorEX *
kArgumentTypeList_uint64OrError [2] = {& kTypeDescriptor_GGS_basic_type ,
                              & kTypeDescriptor_GGS_string} ;

const C_galgas_function_descriptorEX
kFunction_descriptor_uint64OrError ("uint64OrError",
                              functionForGenericCall_uint64OrError,
                              & kTypeDescriptor_GGS_uint64 ,
                              2,
                              kArgumentTypeList_uint64OrError) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               Implementation of function "luint64OrError"                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_luint64  function_luint64OrError (C_Compiler & inLexique,
                                GGS_basic_type   var_cas_t,
                                GGS_string  var_cas_att COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_luint64OrError at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_luint64  var_cas_v ;
  { const GGS_basic_type _var_1870 = var_cas_t ; // CAST instruction
    if (_var_1870.getPtr () != NULL) {
      macroValidPointer (_var_1870.getPtr ()) ;
      if (typeid (cPtr_uint64_class) == typeid (* (_var_1870.getPtr ()))) {
        const GGS_uint64_class var_cas_ui (_var_1870.getPtr ()) ;
        var_cas_v = GGS_luint64 ::constructor_new (inLexique, var_cas_ui.reader_value (inLexique COMMA_SOURCE_FILE_AT_LINE (93)), var_cas_ui.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (93)) COMMA_SOURCE_FILE_AT_LINE (93)) ;
      }else{
        var_cas_v = GGS_luint64 ::constructor_new (inLexique, GGS_uint64 (0ULL), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (95)) ;
        var_cas_t.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (96)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("Internal error, ")).operator_concat (var_cas_att)).operator_concat (GGS_string (" has a wrong datatype")) COMMA_SOURCE_FILE_AT_LINE (97)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_luint64OrError\n") ;
  #endif
  return var_cas_v ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_luint64OrError (C_Compiler & inLexique,
                           const GGS_objectlist & inEffectiveParameterArray,
                           const GGS_location & inErrorLocation
                           COMMA_LOCATION_ARGS) {
  const GGS_basic_type  arg_0 = GGS_basic_type ::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (0) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_string arg_1 = GGS_string::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (1) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_luint64  result = function_luint64OrError (inLexique,
                            arg_0,
                            arg_1
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

static const C_galgas_type_descriptorEX *
kArgumentTypeList_luint64OrError [2] = {& kTypeDescriptor_GGS_basic_type ,
                              & kTypeDescriptor_GGS_string} ;

const C_galgas_function_descriptorEX
kFunction_descriptor_luint64OrError ("luint64OrError",
                              functionForGenericCall_luint64OrError,
                              & kTypeDescriptor_GGS_luint64 ,
                              2,
                              kArgumentTypeList_luint64OrError) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_sint64_class'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sint64_class::
cPtr_sint64_class (const GGS_location & argument_0,
                                const GGS_sint64 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_basic_type (argument_0 COMMA_THERE),
value (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sint64_class * GGS_sint64_class::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_sint64_class) ;
    return (cPtr_sint64_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sint64_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sint64_class * ptr = dynamic_cast <const cPtr_sint64_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sint64_class::
method_string (C_Compiler & inLexique,
                                GGS_string& var_cas_s COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_s = value.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (103)) ;
}

//---------------------------------------------------------------------------*

void cPtr_sint64_class::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sint64_class:"
           << location.reader_description (inIndentation + 1)
           << value.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sint64_class::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sint64_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sint64_class (& typeid (cPtr_sint64_class), & typeid (cPtr_basic_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sint64_class::galgasRTTI (void) const {
  return & gClassInfoFor__sint64_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sint64_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sint64_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_sint64_class'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sint64_class ("sint64_class", true, & kTypeDescriptor_GGS_basic_type) ;

//---------------------------------------------------------------------------*

GGS_sint64_class::
GGS_sint64_class (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sint64_class::
GGS_sint64_class (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sint64_class GGS_sint64_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sint64_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sint64_class *> (inPointer) != NULL)
      : (typeid (cPtr_sint64_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sint64_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sint64_class),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64_class GGS_sint64_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_sint64 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_sint64_class result ;
  macroMyNew (result.mPointer, cPtr_sint64_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64  GGS_sint64_class::
reader_value (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint64_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sint64_class *) mPointer)->value ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sint64_class::actualTypeName (void) const {
  return "sint64_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sint64_class ("sint64_class", gClassInfoFor__basic_type, & kTypeDescriptor_GGS_sint64_class) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sint64_class::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sint64_class * p = NULL ;
    macroMyNew (p, GGS_sint64_class (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64_class GGS_sint64_class::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sint64_class result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sint64_class * p = dynamic_cast <const GGS_sint64_class *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sint64_class, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sint64_class::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sint64_class ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_float_class'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_float_class::
cPtr_float_class (const GGS_location & argument_0,
                                const GGS_double& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_basic_type (argument_0 COMMA_THERE),
value (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_float_class * GGS_float_class::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_float_class) ;
    return (cPtr_float_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_float_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_float_class * ptr = dynamic_cast <const cPtr_float_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_float_class::
method_string (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_s COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_s = GGS_string ("") ;
}

//---------------------------------------------------------------------------*

void cPtr_float_class::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@float_class:"
           << location.reader_description (inIndentation + 1)
           << value.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_float_class::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_float_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_float_class (& typeid (cPtr_float_class), & typeid (cPtr_basic_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_float_class::galgasRTTI (void) const {
  return & gClassInfoFor__float_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_float_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_float_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_float_class'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_float_class ("float_class", true, & kTypeDescriptor_GGS_basic_type) ;

//---------------------------------------------------------------------------*

GGS_float_class::
GGS_float_class (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_float_class::
GGS_float_class (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_float_class GGS_float_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_float_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_float_class *> (inPointer) != NULL)
      : (typeid (cPtr_float_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_float_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_float_class),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_float_class GGS_float_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_double& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_float_class result ;
  macroMyNew (result.mPointer, cPtr_float_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_double GGS_float_class::
reader_value (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_double  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_float_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_float_class *) mPointer)->value ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_float_class::actualTypeName (void) const {
  return "float_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__float_class ("float_class", gClassInfoFor__basic_type, & kTypeDescriptor_GGS_float_class) ;

//---------------------------------------------------------------------------*

GGS_object GGS_float_class::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_float_class * p = NULL ;
    macroMyNew (p, GGS_float_class (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_float_class GGS_float_class::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_float_class result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_float_class * p = dynamic_cast <const GGS_float_class *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_float_class, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_float_class::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_float_class ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_string_class'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_string_class::
cPtr_string_class (const GGS_location & argument_0,
                                const GGS_string& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_basic_type (argument_0 COMMA_THERE),
value (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_string_class * GGS_string_class::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_string_class) ;
    return (cPtr_string_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_string_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_string_class * ptr = dynamic_cast <const cPtr_string_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_string_class::
method_string (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_s COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_s = value ;
}

//---------------------------------------------------------------------------*

void cPtr_string_class::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@string_class:"
           << location.reader_description (inIndentation + 1)
           << value.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_string_class::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_string_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_string_class (& typeid (cPtr_string_class), & typeid (cPtr_basic_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_string_class::galgasRTTI (void) const {
  return & gClassInfoFor__string_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_string_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_string_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_string_class'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_string_class ("string_class", true, & kTypeDescriptor_GGS_basic_type) ;

//---------------------------------------------------------------------------*

GGS_string_class::
GGS_string_class (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_string_class::
GGS_string_class (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_string_class GGS_string_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_string_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_string_class *> (inPointer) != NULL)
      : (typeid (cPtr_string_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_string_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_string_class),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string_class GGS_string_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_string& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_string_class result ;
  macroMyNew (result.mPointer, cPtr_string_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_string_class::
reader_value (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_string_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_string_class *) mPointer)->value ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_string_class::actualTypeName (void) const {
  return "string_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__string_class ("string_class", gClassInfoFor__basic_type, & kTypeDescriptor_GGS_string_class) ;

//---------------------------------------------------------------------------*

GGS_object GGS_string_class::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_string_class * p = NULL ;
    macroMyNew (p, GGS_string_class (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string_class GGS_string_class::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_string_class result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_string_class * p = dynamic_cast <const GGS_string_class *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_string_class, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_string_class::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_string_class ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_bool_class'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_bool_class::
cPtr_bool_class (const GGS_location & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_basic_type (argument_0 COMMA_THERE),
value (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_bool_class * GGS_bool_class::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_bool_class) ;
    return (cPtr_bool_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_bool_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_bool_class * ptr = dynamic_cast <const cPtr_bool_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_bool_class::
method_string (C_Compiler & /* inLexique */,
                                GGS_string& var_cas_s COMMA_UNUSED_LOCATION_ARGS) const {
  const GGS_bool cond_2453 = value ;
  if (cond_2453.isBuiltAndTrue ()) {
    var_cas_s = GGS_string ("true") ;
  }else if (cond_2453.isBuiltAndFalse ()) {
    var_cas_s = GGS_string ("false") ;
  }
}

//---------------------------------------------------------------------------*

void cPtr_bool_class::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@bool_class:"
           << location.reader_description (inIndentation + 1)
           << value.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_bool_class::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_bool_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_bool_class (& typeid (cPtr_bool_class), & typeid (cPtr_basic_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_bool_class::galgasRTTI (void) const {
  return & gClassInfoFor__bool_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_bool_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_bool_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_bool_class'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_bool_class ("bool_class", true, & kTypeDescriptor_GGS_basic_type) ;

//---------------------------------------------------------------------------*

GGS_bool_class::
GGS_bool_class (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_bool_class::
GGS_bool_class (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_bool_class GGS_bool_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_bool_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_bool_class *> (inPointer) != NULL)
      : (typeid (cPtr_bool_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_bool_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_bool_class),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool_class GGS_bool_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_bool_class result ;
  macroMyNew (result.mPointer, cPtr_bool_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_bool_class::
reader_value (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_bool_class *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_bool_class *) mPointer)->value ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_bool_class::actualTypeName (void) const {
  return "bool_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__bool_class ("bool_class", gClassInfoFor__basic_type, & kTypeDescriptor_GGS_bool_class) ;

//---------------------------------------------------------------------------*

GGS_object GGS_bool_class::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_bool_class * p = NULL ;
    macroMyNew (p, GGS_bool_class (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool_class GGS_bool_class::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_bool_class result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_bool_class * p = dynamic_cast <const GGS_bool_class *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_bool_class, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_bool_class::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_bool_class ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_void_uint32_class'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_void_uint32_class::
cPtr_void_uint32_class (const GGS_location & argument_0,
                                const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_uint32_class (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_void_uint32_class * GGS_void_uint32_class::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_void_uint32_class) ;
    return (cPtr_void_uint32_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_void_uint32_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_void_uint32_class * ptr = dynamic_cast <const cPtr_void_uint32_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_void_uint32_class::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@void_uint32_class:"
           << location.reader_description (inIndentation + 1)
           << value.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_void_uint32_class::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_void_uint32_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_void_uint32_class (& typeid (cPtr_void_uint32_class), & typeid (cPtr_uint32_class), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_void_uint32_class::galgasRTTI (void) const {
  return & gClassInfoFor__void_uint32_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_void_uint32_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_void_uint32_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_void_uint32_class'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_void_uint32_class ("void_uint32_class", true, & kTypeDescriptor_GGS_uint32_class) ;

//---------------------------------------------------------------------------*

GGS_void_uint32_class::
GGS_void_uint32_class (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_void_uint32_class::
GGS_void_uint32_class (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_void_uint32_class GGS_void_uint32_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_void_uint32_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_void_uint32_class *> (inPointer) != NULL)
      : (typeid (cPtr_void_uint32_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_void_uint32_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_void_uint32_class),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_uint32_class GGS_void_uint32_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_void_uint32_class result ;
  macroMyNew (result.mPointer, cPtr_void_uint32_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_void_uint32_class::actualTypeName (void) const {
  return "void_uint32_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__void_uint32_class ("void_uint32_class", gClassInfoFor__uint32_class, & kTypeDescriptor_GGS_void_uint32_class) ;

//---------------------------------------------------------------------------*

GGS_object GGS_void_uint32_class::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_void_uint32_class * p = NULL ;
    macroMyNew (p, GGS_void_uint32_class (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_uint32_class GGS_void_uint32_class::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_void_uint32_class result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_void_uint32_class * p = dynamic_cast <const GGS_void_uint32_class *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_void_uint32_class, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_void_uint32_class::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_void_uint32_class ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_void_sint32_class'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_void_sint32_class::
cPtr_void_sint32_class (const GGS_location & argument_0,
                                const GGS_sint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_sint32_class (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_void_sint32_class * GGS_void_sint32_class::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_void_sint32_class) ;
    return (cPtr_void_sint32_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_void_sint32_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_void_sint32_class * ptr = dynamic_cast <const cPtr_void_sint32_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_void_sint32_class::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@void_sint32_class:"
           << location.reader_description (inIndentation + 1)
           << value.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_void_sint32_class::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_void_sint32_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_void_sint32_class (& typeid (cPtr_void_sint32_class), & typeid (cPtr_sint32_class), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_void_sint32_class::galgasRTTI (void) const {
  return & gClassInfoFor__void_sint32_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_void_sint32_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_void_sint32_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_void_sint32_class'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_void_sint32_class ("void_sint32_class", true, & kTypeDescriptor_GGS_sint32_class) ;

//---------------------------------------------------------------------------*

GGS_void_sint32_class::
GGS_void_sint32_class (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_void_sint32_class::
GGS_void_sint32_class (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_void_sint32_class GGS_void_sint32_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_void_sint32_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_void_sint32_class *> (inPointer) != NULL)
      : (typeid (cPtr_void_sint32_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_void_sint32_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_void_sint32_class),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_sint32_class GGS_void_sint32_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_sint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_void_sint32_class result ;
  macroMyNew (result.mPointer, cPtr_void_sint32_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_void_sint32_class::actualTypeName (void) const {
  return "void_sint32_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__void_sint32_class ("void_sint32_class", gClassInfoFor__sint32_class, & kTypeDescriptor_GGS_void_sint32_class) ;

//---------------------------------------------------------------------------*

GGS_object GGS_void_sint32_class::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_void_sint32_class * p = NULL ;
    macroMyNew (p, GGS_void_sint32_class (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_sint32_class GGS_void_sint32_class::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_void_sint32_class result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_void_sint32_class * p = dynamic_cast <const GGS_void_sint32_class *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_void_sint32_class, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_void_sint32_class::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_void_sint32_class ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_void_uint64_class'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_void_uint64_class::
cPtr_void_uint64_class (const GGS_location & argument_0,
                                const GGS_uint64 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_uint64_class (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_void_uint64_class * GGS_void_uint64_class::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_void_uint64_class) ;
    return (cPtr_void_uint64_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_void_uint64_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_void_uint64_class * ptr = dynamic_cast <const cPtr_void_uint64_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_void_uint64_class::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@void_uint64_class:"
           << location.reader_description (inIndentation + 1)
           << value.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_void_uint64_class::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_void_uint64_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_void_uint64_class (& typeid (cPtr_void_uint64_class), & typeid (cPtr_uint64_class), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_void_uint64_class::galgasRTTI (void) const {
  return & gClassInfoFor__void_uint64_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_void_uint64_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_void_uint64_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_void_uint64_class'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_void_uint64_class ("void_uint64_class", true, & kTypeDescriptor_GGS_uint64_class) ;

//---------------------------------------------------------------------------*

GGS_void_uint64_class::
GGS_void_uint64_class (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_void_uint64_class::
GGS_void_uint64_class (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_void_uint64_class GGS_void_uint64_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_void_uint64_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_void_uint64_class *> (inPointer) != NULL)
      : (typeid (cPtr_void_uint64_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_void_uint64_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_void_uint64_class),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_uint64_class GGS_void_uint64_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_uint64 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_void_uint64_class result ;
  macroMyNew (result.mPointer, cPtr_void_uint64_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_void_uint64_class::actualTypeName (void) const {
  return "void_uint64_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__void_uint64_class ("void_uint64_class", gClassInfoFor__uint64_class, & kTypeDescriptor_GGS_void_uint64_class) ;

//---------------------------------------------------------------------------*

GGS_object GGS_void_uint64_class::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_void_uint64_class * p = NULL ;
    macroMyNew (p, GGS_void_uint64_class (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_uint64_class GGS_void_uint64_class::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_void_uint64_class result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_void_uint64_class * p = dynamic_cast <const GGS_void_uint64_class *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_void_uint64_class, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_void_uint64_class::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_void_uint64_class ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_void_sint64_class'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_void_sint64_class::
cPtr_void_sint64_class (const GGS_location & argument_0,
                                const GGS_sint64 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_sint64_class (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_void_sint64_class * GGS_void_sint64_class::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_void_sint64_class) ;
    return (cPtr_void_sint64_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_void_sint64_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_void_sint64_class * ptr = dynamic_cast <const cPtr_void_sint64_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_void_sint64_class::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@void_sint64_class:"
           << location.reader_description (inIndentation + 1)
           << value.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_void_sint64_class::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_void_sint64_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_void_sint64_class (& typeid (cPtr_void_sint64_class), & typeid (cPtr_sint64_class), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_void_sint64_class::galgasRTTI (void) const {
  return & gClassInfoFor__void_sint64_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_void_sint64_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_void_sint64_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_void_sint64_class'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_void_sint64_class ("void_sint64_class", true, & kTypeDescriptor_GGS_sint64_class) ;

//---------------------------------------------------------------------------*

GGS_void_sint64_class::
GGS_void_sint64_class (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_void_sint64_class::
GGS_void_sint64_class (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_void_sint64_class GGS_void_sint64_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_void_sint64_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_void_sint64_class *> (inPointer) != NULL)
      : (typeid (cPtr_void_sint64_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_void_sint64_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_void_sint64_class),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_sint64_class GGS_void_sint64_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_sint64 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_void_sint64_class result ;
  macroMyNew (result.mPointer, cPtr_void_sint64_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_void_sint64_class::actualTypeName (void) const {
  return "void_sint64_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__void_sint64_class ("void_sint64_class", gClassInfoFor__sint64_class, & kTypeDescriptor_GGS_void_sint64_class) ;

//---------------------------------------------------------------------------*

GGS_object GGS_void_sint64_class::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_void_sint64_class * p = NULL ;
    macroMyNew (p, GGS_void_sint64_class (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_sint64_class GGS_void_sint64_class::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_void_sint64_class result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_void_sint64_class * p = dynamic_cast <const GGS_void_sint64_class *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_void_sint64_class, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_void_sint64_class::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_void_sint64_class ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_void_float_class'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_void_float_class::
cPtr_void_float_class (const GGS_location & argument_0,
                                const GGS_double& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_float_class (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_void_float_class * GGS_void_float_class::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_void_float_class) ;
    return (cPtr_void_float_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_void_float_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_void_float_class * ptr = dynamic_cast <const cPtr_void_float_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_void_float_class::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@void_float_class:"
           << location.reader_description (inIndentation + 1)
           << value.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_void_float_class::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_void_float_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_void_float_class (& typeid (cPtr_void_float_class), & typeid (cPtr_float_class), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_void_float_class::galgasRTTI (void) const {
  return & gClassInfoFor__void_float_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_void_float_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_void_float_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_void_float_class'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_void_float_class ("void_float_class", true, & kTypeDescriptor_GGS_float_class) ;

//---------------------------------------------------------------------------*

GGS_void_float_class::
GGS_void_float_class (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_void_float_class::
GGS_void_float_class (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_void_float_class GGS_void_float_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_void_float_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_void_float_class *> (inPointer) != NULL)
      : (typeid (cPtr_void_float_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_void_float_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_void_float_class),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_float_class GGS_void_float_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_double& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_void_float_class result ;
  macroMyNew (result.mPointer, cPtr_void_float_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_void_float_class::actualTypeName (void) const {
  return "void_float_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__void_float_class ("void_float_class", gClassInfoFor__float_class, & kTypeDescriptor_GGS_void_float_class) ;

//---------------------------------------------------------------------------*

GGS_object GGS_void_float_class::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_void_float_class * p = NULL ;
    macroMyNew (p, GGS_void_float_class (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_float_class GGS_void_float_class::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_void_float_class result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_void_float_class * p = dynamic_cast <const GGS_void_float_class *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_void_float_class, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_void_float_class::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_void_float_class ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_void_string_class'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_void_string_class::
cPtr_void_string_class (const GGS_location & argument_0,
                                const GGS_string& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_string_class (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_void_string_class * GGS_void_string_class::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_void_string_class) ;
    return (cPtr_void_string_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_void_string_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_void_string_class * ptr = dynamic_cast <const cPtr_void_string_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_void_string_class::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@void_string_class:"
           << location.reader_description (inIndentation + 1)
           << value.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_void_string_class::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_void_string_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_void_string_class (& typeid (cPtr_void_string_class), & typeid (cPtr_string_class), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_void_string_class::galgasRTTI (void) const {
  return & gClassInfoFor__void_string_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_void_string_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_void_string_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_void_string_class'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_void_string_class ("void_string_class", true, & kTypeDescriptor_GGS_string_class) ;

//---------------------------------------------------------------------------*

GGS_void_string_class::
GGS_void_string_class (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_void_string_class::
GGS_void_string_class (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_void_string_class GGS_void_string_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_void_string_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_void_string_class *> (inPointer) != NULL)
      : (typeid (cPtr_void_string_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_void_string_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_void_string_class),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_string_class GGS_void_string_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_string& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_void_string_class result ;
  macroMyNew (result.mPointer, cPtr_void_string_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_void_string_class::actualTypeName (void) const {
  return "void_string_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__void_string_class ("void_string_class", gClassInfoFor__string_class, & kTypeDescriptor_GGS_void_string_class) ;

//---------------------------------------------------------------------------*

GGS_object GGS_void_string_class::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_void_string_class * p = NULL ;
    macroMyNew (p, GGS_void_string_class (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_string_class GGS_void_string_class::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_void_string_class result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_void_string_class * p = dynamic_cast <const GGS_void_string_class *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_void_string_class, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_void_string_class::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_void_string_class ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_void_bool_class'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_void_bool_class::
cPtr_void_bool_class (const GGS_location & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_bool_class (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_void_bool_class * GGS_void_bool_class::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_void_bool_class) ;
    return (cPtr_void_bool_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_void_bool_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_void_bool_class * ptr = dynamic_cast <const cPtr_void_bool_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_void_bool_class::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@void_bool_class:"
           << location.reader_description (inIndentation + 1)
           << value.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_void_bool_class::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_void_bool_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_void_bool_class (& typeid (cPtr_void_bool_class), & typeid (cPtr_bool_class), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_void_bool_class::galgasRTTI (void) const {
  return & gClassInfoFor__void_bool_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_void_bool_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_void_bool_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_void_bool_class'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_void_bool_class ("void_bool_class", true, & kTypeDescriptor_GGS_bool_class) ;

//---------------------------------------------------------------------------*

GGS_void_bool_class::
GGS_void_bool_class (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_void_bool_class::
GGS_void_bool_class (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_void_bool_class GGS_void_bool_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_void_bool_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_void_bool_class *> (inPointer) != NULL)
      : (typeid (cPtr_void_bool_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_void_bool_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_void_bool_class),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_bool_class GGS_void_bool_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_void_bool_class result ;
  macroMyNew (result.mPointer, cPtr_void_bool_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_void_bool_class::actualTypeName (void) const {
  return "void_bool_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__void_bool_class ("void_bool_class", gClassInfoFor__bool_class, & kTypeDescriptor_GGS_void_bool_class) ;

//---------------------------------------------------------------------------*

GGS_object GGS_void_bool_class::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_void_bool_class * p = NULL ;
    macroMyNew (p, GGS_void_bool_class (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_bool_class GGS_void_bool_class::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_void_bool_class result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_void_bool_class * p = dynamic_cast <const GGS_void_bool_class *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_void_bool_class, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_void_bool_class::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_void_bool_class ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_auto_uint32_class'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_auto_uint32_class::
cPtr_auto_uint32_class (const GGS_location & argument_0,
                                const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_uint32_class (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_auto_uint32_class * GGS_auto_uint32_class::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_auto_uint32_class) ;
    return (cPtr_auto_uint32_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_auto_uint32_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_auto_uint32_class * ptr = dynamic_cast <const cPtr_auto_uint32_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_auto_uint32_class::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@auto_uint32_class:"
           << location.reader_description (inIndentation + 1)
           << value.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_auto_uint32_class::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_auto_uint32_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_auto_uint32_class (& typeid (cPtr_auto_uint32_class), & typeid (cPtr_uint32_class), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_auto_uint32_class::galgasRTTI (void) const {
  return & gClassInfoFor__auto_uint32_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_auto_uint32_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_auto_uint32_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_auto_uint32_class'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_auto_uint32_class ("auto_uint32_class", true, & kTypeDescriptor_GGS_uint32_class) ;

//---------------------------------------------------------------------------*

GGS_auto_uint32_class::
GGS_auto_uint32_class (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_auto_uint32_class::
GGS_auto_uint32_class (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_auto_uint32_class GGS_auto_uint32_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_auto_uint32_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_auto_uint32_class *> (inPointer) != NULL)
      : (typeid (cPtr_auto_uint32_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_auto_uint32_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_auto_uint32_class),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_auto_uint32_class GGS_auto_uint32_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_auto_uint32_class result ;
  macroMyNew (result.mPointer, cPtr_auto_uint32_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_auto_uint32_class::actualTypeName (void) const {
  return "auto_uint32_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__auto_uint32_class ("auto_uint32_class", gClassInfoFor__uint32_class, & kTypeDescriptor_GGS_auto_uint32_class) ;

//---------------------------------------------------------------------------*

GGS_object GGS_auto_uint32_class::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_auto_uint32_class * p = NULL ;
    macroMyNew (p, GGS_auto_uint32_class (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_auto_uint32_class GGS_auto_uint32_class::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_auto_uint32_class result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_auto_uint32_class * p = dynamic_cast <const GGS_auto_uint32_class *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_auto_uint32_class, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_auto_uint32_class::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_auto_uint32_class ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_auto_sint32_class'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_auto_sint32_class::
cPtr_auto_sint32_class (const GGS_location & argument_0,
                                const GGS_sint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_sint32_class (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_auto_sint32_class * GGS_auto_sint32_class::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_auto_sint32_class) ;
    return (cPtr_auto_sint32_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_auto_sint32_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_auto_sint32_class * ptr = dynamic_cast <const cPtr_auto_sint32_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_auto_sint32_class::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@auto_sint32_class:"
           << location.reader_description (inIndentation + 1)
           << value.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_auto_sint32_class::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_auto_sint32_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_auto_sint32_class (& typeid (cPtr_auto_sint32_class), & typeid (cPtr_sint32_class), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_auto_sint32_class::galgasRTTI (void) const {
  return & gClassInfoFor__auto_sint32_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_auto_sint32_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_auto_sint32_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_auto_sint32_class'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_auto_sint32_class ("auto_sint32_class", true, & kTypeDescriptor_GGS_sint32_class) ;

//---------------------------------------------------------------------------*

GGS_auto_sint32_class::
GGS_auto_sint32_class (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_auto_sint32_class::
GGS_auto_sint32_class (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_auto_sint32_class GGS_auto_sint32_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_auto_sint32_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_auto_sint32_class *> (inPointer) != NULL)
      : (typeid (cPtr_auto_sint32_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_auto_sint32_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_auto_sint32_class),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_auto_sint32_class GGS_auto_sint32_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_sint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_auto_sint32_class result ;
  macroMyNew (result.mPointer, cPtr_auto_sint32_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_auto_sint32_class::actualTypeName (void) const {
  return "auto_sint32_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__auto_sint32_class ("auto_sint32_class", gClassInfoFor__sint32_class, & kTypeDescriptor_GGS_auto_sint32_class) ;

//---------------------------------------------------------------------------*

GGS_object GGS_auto_sint32_class::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_auto_sint32_class * p = NULL ;
    macroMyNew (p, GGS_auto_sint32_class (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_auto_sint32_class GGS_auto_sint32_class::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_auto_sint32_class result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_auto_sint32_class * p = dynamic_cast <const GGS_auto_sint32_class *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_auto_sint32_class, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_auto_sint32_class::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_auto_sint32_class ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_auto_uint64_class'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_auto_uint64_class::
cPtr_auto_uint64_class (const GGS_location & argument_0,
                                const GGS_uint64 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_uint64_class (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_auto_uint64_class * GGS_auto_uint64_class::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_auto_uint64_class) ;
    return (cPtr_auto_uint64_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_auto_uint64_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_auto_uint64_class * ptr = dynamic_cast <const cPtr_auto_uint64_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_auto_uint64_class::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@auto_uint64_class:"
           << location.reader_description (inIndentation + 1)
           << value.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_auto_uint64_class::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_auto_uint64_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_auto_uint64_class (& typeid (cPtr_auto_uint64_class), & typeid (cPtr_uint64_class), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_auto_uint64_class::galgasRTTI (void) const {
  return & gClassInfoFor__auto_uint64_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_auto_uint64_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_auto_uint64_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_auto_uint64_class'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_auto_uint64_class ("auto_uint64_class", true, & kTypeDescriptor_GGS_uint64_class) ;

//---------------------------------------------------------------------------*

GGS_auto_uint64_class::
GGS_auto_uint64_class (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_auto_uint64_class::
GGS_auto_uint64_class (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_auto_uint64_class GGS_auto_uint64_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_auto_uint64_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_auto_uint64_class *> (inPointer) != NULL)
      : (typeid (cPtr_auto_uint64_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_auto_uint64_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_auto_uint64_class),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_auto_uint64_class GGS_auto_uint64_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_uint64 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_auto_uint64_class result ;
  macroMyNew (result.mPointer, cPtr_auto_uint64_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_auto_uint64_class::actualTypeName (void) const {
  return "auto_uint64_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__auto_uint64_class ("auto_uint64_class", gClassInfoFor__uint64_class, & kTypeDescriptor_GGS_auto_uint64_class) ;

//---------------------------------------------------------------------------*

GGS_object GGS_auto_uint64_class::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_auto_uint64_class * p = NULL ;
    macroMyNew (p, GGS_auto_uint64_class (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_auto_uint64_class GGS_auto_uint64_class::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_auto_uint64_class result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_auto_uint64_class * p = dynamic_cast <const GGS_auto_uint64_class *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_auto_uint64_class, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_auto_uint64_class::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_auto_uint64_class ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_auto_sint64_class'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_auto_sint64_class::
cPtr_auto_sint64_class (const GGS_location & argument_0,
                                const GGS_sint64 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_sint64_class (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_auto_sint64_class * GGS_auto_sint64_class::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_auto_sint64_class) ;
    return (cPtr_auto_sint64_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_auto_sint64_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_auto_sint64_class * ptr = dynamic_cast <const cPtr_auto_sint64_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_auto_sint64_class::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@auto_sint64_class:"
           << location.reader_description (inIndentation + 1)
           << value.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_auto_sint64_class::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_auto_sint64_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_auto_sint64_class (& typeid (cPtr_auto_sint64_class), & typeid (cPtr_sint64_class), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_auto_sint64_class::galgasRTTI (void) const {
  return & gClassInfoFor__auto_sint64_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_auto_sint64_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_auto_sint64_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_auto_sint64_class'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_auto_sint64_class ("auto_sint64_class", true, & kTypeDescriptor_GGS_sint64_class) ;

//---------------------------------------------------------------------------*

GGS_auto_sint64_class::
GGS_auto_sint64_class (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_auto_sint64_class::
GGS_auto_sint64_class (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_auto_sint64_class GGS_auto_sint64_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_auto_sint64_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_auto_sint64_class *> (inPointer) != NULL)
      : (typeid (cPtr_auto_sint64_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_auto_sint64_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_auto_sint64_class),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_auto_sint64_class GGS_auto_sint64_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_sint64 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_auto_sint64_class result ;
  macroMyNew (result.mPointer, cPtr_auto_sint64_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_auto_sint64_class::actualTypeName (void) const {
  return "auto_sint64_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__auto_sint64_class ("auto_sint64_class", gClassInfoFor__sint64_class, & kTypeDescriptor_GGS_auto_sint64_class) ;

//---------------------------------------------------------------------------*

GGS_object GGS_auto_sint64_class::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_auto_sint64_class * p = NULL ;
    macroMyNew (p, GGS_auto_sint64_class (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_auto_sint64_class GGS_auto_sint64_class::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_auto_sint64_class result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_auto_sint64_class * p = dynamic_cast <const GGS_auto_sint64_class *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_auto_sint64_class, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_auto_sint64_class::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_auto_sint64_class ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_auto_string_class'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_auto_string_class::
cPtr_auto_string_class (const GGS_location & argument_0,
                                const GGS_string& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_string_class (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_auto_string_class * GGS_auto_string_class::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_auto_string_class) ;
    return (cPtr_auto_string_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_auto_string_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_auto_string_class * ptr = dynamic_cast <const cPtr_auto_string_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_auto_string_class::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@auto_string_class:"
           << location.reader_description (inIndentation + 1)
           << value.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_auto_string_class::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_auto_string_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_auto_string_class (& typeid (cPtr_auto_string_class), & typeid (cPtr_string_class), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_auto_string_class::galgasRTTI (void) const {
  return & gClassInfoFor__auto_string_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_auto_string_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_auto_string_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_auto_string_class'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_auto_string_class ("auto_string_class", true, & kTypeDescriptor_GGS_string_class) ;

//---------------------------------------------------------------------------*

GGS_auto_string_class::
GGS_auto_string_class (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_auto_string_class::
GGS_auto_string_class (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_auto_string_class GGS_auto_string_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_auto_string_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_auto_string_class *> (inPointer) != NULL)
      : (typeid (cPtr_auto_string_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_auto_string_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_auto_string_class),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_auto_string_class GGS_auto_string_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_string& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_auto_string_class result ;
  macroMyNew (result.mPointer, cPtr_auto_string_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_auto_string_class::actualTypeName (void) const {
  return "auto_string_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__auto_string_class ("auto_string_class", gClassInfoFor__string_class, & kTypeDescriptor_GGS_auto_string_class) ;

//---------------------------------------------------------------------------*

GGS_object GGS_auto_string_class::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_auto_string_class * p = NULL ;
    macroMyNew (p, GGS_auto_string_class (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_auto_string_class GGS_auto_string_class::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_auto_string_class result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_auto_string_class * p = dynamic_cast <const GGS_auto_string_class *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_auto_string_class, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_auto_string_class::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_auto_string_class ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_auto_bool_class'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_auto_bool_class::
cPtr_auto_bool_class (const GGS_location & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_bool_class (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_auto_bool_class * GGS_auto_bool_class::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_auto_bool_class) ;
    return (cPtr_auto_bool_class *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_auto_bool_class::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_auto_bool_class * ptr = dynamic_cast <const cPtr_auto_bool_class *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue ()
         && value.operator_isEqual (ptr->value).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_auto_bool_class::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@auto_bool_class:"
           << location.reader_description (inIndentation + 1)
           << value.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_auto_bool_class::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_auto_bool_class::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_auto_bool_class (& typeid (cPtr_auto_bool_class), & typeid (cPtr_bool_class), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_auto_bool_class::galgasRTTI (void) const {
  return & gClassInfoFor__auto_bool_class ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_auto_bool_class::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_auto_bool_class (location, value COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_auto_bool_class'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_auto_bool_class ("auto_bool_class", true, & kTypeDescriptor_GGS_bool_class) ;

//---------------------------------------------------------------------------*

GGS_auto_bool_class::
GGS_auto_bool_class (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_auto_bool_class::
GGS_auto_bool_class (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_auto_bool_class GGS_auto_bool_class::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_auto_bool_class result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_auto_bool_class *> (inPointer) != NULL)
      : (typeid (cPtr_auto_bool_class) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_auto_bool_class (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_auto_bool_class),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_auto_bool_class GGS_auto_bool_class::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_auto_bool_class result ;
  macroMyNew (result.mPointer, cPtr_auto_bool_class (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_auto_bool_class::actualTypeName (void) const {
  return "auto_bool_class" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__auto_bool_class ("auto_bool_class", gClassInfoFor__bool_class, & kTypeDescriptor_GGS_auto_bool_class) ;

//---------------------------------------------------------------------------*

GGS_object GGS_auto_bool_class::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_auto_bool_class * p = NULL ;
    macroMyNew (p, GGS_auto_bool_class (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_auto_bool_class GGS_auto_bool_class::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_auto_bool_class result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_auto_bool_class * p = dynamic_cast <const GGS_auto_bool_class *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_auto_bool_class, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_auto_bool_class::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_auto_bool_class ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Element of list '@list_uint32'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_list_uint32::
elementOf_GGS_list_uint32 (const GGS_uint & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
val (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_list_uint32::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_list_uint32 * ptr = dynamic_cast <const elementOf_GGS_list_uint32 *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = val.operator_isEqual (ptr->val).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_list_uint32::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << val.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           List '@list_uint32'                             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_list_uint32 ("list_uint32", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_list_uint32::
internalAppendValues (const GGS_uint & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_list_uint32::
internalPrependValues (const GGS_uint & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_list_uint32::
addAssign_operation (const GGS_uint & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_list_uint32 GGS_list_uint32::
operator_concat (const GGS_list_uint32 & inOperand) const {
  GGS_list_uint32 result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_list_uint32::
dotAssign_operation (const GGS_list_uint32 inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_list_uint32 * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_uint  p_0 = p->val ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_list_uint32::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_uint & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_list_uint32::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->val
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_list_uint32  GGS_list_uint32::
constructor_emptyList (void) {
  GGS_list_uint32 result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_list_uint32  GGS_list_uint32::
constructor_listWithValue (const GGS_uint & argument_0) {
  GGS_list_uint32 result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_list_uint32::
internalSubListWithRange (GGS_list_uint32 & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->val) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_list_uint32 GGS_list_uint32::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_list_uint32 result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_list_uint32 GGS_list_uint32::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_list_uint32 result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_list_uint32::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@list_uint32", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_list_uint32::
method_first (C_Compiler & inLexique,
              GGS_uint & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->val ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_list_uint32::
method_last (C_Compiler & inLexique,
             GGS_uint & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->val ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_list_uint32::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_uint & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->val ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_list_uint32::
modifier_popLast (C_Compiler & inLexique,
                GGS_uint & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->val ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_list_uint32::
reader_valAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_uint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->val ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_list_uint32::
modifier_setValAtIndex (C_Compiler & inLexique,
                              const GGS_uint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->val = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_list_uint32::cEnumerator::_val (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->val ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_list_uint32::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_list_uint32 * p = NULL ;
    macroMyNew (p, GGS_list_uint32 (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_list_uint32 GGS_list_uint32::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_list_uint32 result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_list_uint32 * p = dynamic_cast <const GGS_list_uint32 *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_list_uint32, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_list_uint32::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_list_uint32 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Element of list '@list_sint32'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_list_sint32::
elementOf_GGS_list_sint32 (const GGS_sint & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
val (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_list_sint32::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_list_sint32 * ptr = dynamic_cast <const elementOf_GGS_list_sint32 *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = val.operator_isEqual (ptr->val).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_list_sint32::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << val.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           List '@list_sint32'                             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_list_sint32 ("list_sint32", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_list_sint32::
internalAppendValues (const GGS_sint & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_list_sint32::
internalPrependValues (const GGS_sint & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_list_sint32::
addAssign_operation (const GGS_sint & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_list_sint32 GGS_list_sint32::
operator_concat (const GGS_list_sint32 & inOperand) const {
  GGS_list_sint32 result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_list_sint32::
dotAssign_operation (const GGS_list_sint32 inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_list_sint32 * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_sint  p_0 = p->val ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_list_sint32::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_sint & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_list_sint32::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->val
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_list_sint32  GGS_list_sint32::
constructor_emptyList (void) {
  GGS_list_sint32 result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_list_sint32  GGS_list_sint32::
constructor_listWithValue (const GGS_sint & argument_0) {
  GGS_list_sint32 result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_list_sint32::
internalSubListWithRange (GGS_list_sint32 & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->val) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_list_sint32 GGS_list_sint32::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_list_sint32 result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_list_sint32 GGS_list_sint32::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_list_sint32 result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_list_sint32::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@list_sint32", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_list_sint32::
method_first (C_Compiler & inLexique,
              GGS_sint & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->val ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_list_sint32::
method_last (C_Compiler & inLexique,
             GGS_sint & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->val ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_list_sint32::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_sint & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->val ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_list_sint32::
modifier_popLast (C_Compiler & inLexique,
                GGS_sint & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->val ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_sint  GGS_list_sint32::
reader_valAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_sint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->val ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_list_sint32::
modifier_setValAtIndex (C_Compiler & inLexique,
                              const GGS_sint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->val = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_sint  & GGS_list_sint32::cEnumerator::_val (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->val ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_list_sint32::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_list_sint32 * p = NULL ;
    macroMyNew (p, GGS_list_sint32 (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_list_sint32 GGS_list_sint32::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_list_sint32 result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_list_sint32 * p = dynamic_cast <const GGS_list_sint32 *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_list_sint32, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_list_sint32::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_list_sint32 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Element of list '@list_uint64'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_list_uint64::
elementOf_GGS_list_uint64 (const GGS_uint64 & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
val (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_list_uint64::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_list_uint64 * ptr = dynamic_cast <const elementOf_GGS_list_uint64 *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = val.operator_isEqual (ptr->val).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_list_uint64::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << val.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           List '@list_uint64'                             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_list_uint64 ("list_uint64", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_list_uint64::
internalAppendValues (const GGS_uint64 & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_list_uint64::
internalPrependValues (const GGS_uint64 & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_list_uint64::
addAssign_operation (const GGS_uint64 & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_list_uint64 GGS_list_uint64::
operator_concat (const GGS_list_uint64 & inOperand) const {
  GGS_list_uint64 result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_list_uint64::
dotAssign_operation (const GGS_list_uint64 inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_list_uint64 * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_uint64  p_0 = p->val ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_list_uint64::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_uint64 & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_list_uint64::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->val
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_list_uint64  GGS_list_uint64::
constructor_emptyList (void) {
  GGS_list_uint64 result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_list_uint64  GGS_list_uint64::
constructor_listWithValue (const GGS_uint64 & argument_0) {
  GGS_list_uint64 result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_list_uint64::
internalSubListWithRange (GGS_list_uint64 & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->val) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_list_uint64 GGS_list_uint64::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_list_uint64 result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_list_uint64 GGS_list_uint64::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_list_uint64 result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_list_uint64::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@list_uint64", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_list_uint64::
method_first (C_Compiler & inLexique,
              GGS_uint64 & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->val ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_list_uint64::
method_last (C_Compiler & inLexique,
             GGS_uint64 & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->val ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_list_uint64::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_uint64 & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->val ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_list_uint64::
modifier_popLast (C_Compiler & inLexique,
                GGS_uint64 & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->val ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_uint64  GGS_list_uint64::
reader_valAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_uint64  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->val ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_list_uint64::
modifier_setValAtIndex (C_Compiler & inLexique,
                              const GGS_uint64  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->val = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint64  & GGS_list_uint64::cEnumerator::_val (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->val ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_list_uint64::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_list_uint64 * p = NULL ;
    macroMyNew (p, GGS_list_uint64 (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_list_uint64 GGS_list_uint64::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_list_uint64 result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_list_uint64 * p = dynamic_cast <const GGS_list_uint64 *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_list_uint64, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_list_uint64::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_list_uint64 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Element of list '@list_sint64'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_list_sint64::
elementOf_GGS_list_sint64 (const GGS_sint64 & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
val (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_list_sint64::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_list_sint64 * ptr = dynamic_cast <const elementOf_GGS_list_sint64 *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = val.operator_isEqual (ptr->val).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_list_sint64::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << val.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           List '@list_sint64'                             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_list_sint64 ("list_sint64", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_list_sint64::
internalAppendValues (const GGS_sint64 & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_list_sint64::
internalPrependValues (const GGS_sint64 & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_list_sint64::
addAssign_operation (const GGS_sint64 & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_list_sint64 GGS_list_sint64::
operator_concat (const GGS_list_sint64 & inOperand) const {
  GGS_list_sint64 result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_list_sint64::
dotAssign_operation (const GGS_list_sint64 inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_list_sint64 * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_sint64  p_0 = p->val ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_list_sint64::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_sint64 & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_list_sint64::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->val
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_list_sint64  GGS_list_sint64::
constructor_emptyList (void) {
  GGS_list_sint64 result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_list_sint64  GGS_list_sint64::
constructor_listWithValue (const GGS_sint64 & argument_0) {
  GGS_list_sint64 result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_list_sint64::
internalSubListWithRange (GGS_list_sint64 & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->val) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_list_sint64 GGS_list_sint64::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_list_sint64 result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_list_sint64 GGS_list_sint64::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_list_sint64 result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_list_sint64::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@list_sint64", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_list_sint64::
method_first (C_Compiler & inLexique,
              GGS_sint64 & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->val ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_list_sint64::
method_last (C_Compiler & inLexique,
             GGS_sint64 & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->val ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_list_sint64::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_sint64 & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->val ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_list_sint64::
modifier_popLast (C_Compiler & inLexique,
                GGS_sint64 & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->val ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_sint64  GGS_list_sint64::
reader_valAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_sint64  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->val ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_list_sint64::
modifier_setValAtIndex (C_Compiler & inLexique,
                              const GGS_sint64  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->val = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_sint64  & GGS_list_sint64::cEnumerator::_val (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->val ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_list_sint64::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_list_sint64 * p = NULL ;
    macroMyNew (p, GGS_list_sint64 (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_list_sint64 GGS_list_sint64::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_list_sint64 result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_list_sint64 * p = dynamic_cast <const GGS_list_sint64 *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_list_sint64, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_list_sint64::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_list_sint64 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_number_set'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_number_set::
cPtr_number_set (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
loc (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_number_set * GGS_number_set::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_number_set) ;
    return (cPtr_number_set *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_number_set::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@number_set:"
           << loc.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_number_set::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_number_set::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_number_set (& typeid (cPtr_number_set), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_number_set::galgasRTTI (void) const {
  return & gClassInfoFor__number_set ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_number_set'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_number_set ("number_set", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_number_set::
GGS_number_set (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_number_set::
GGS_number_set (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_number_set GGS_number_set::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_number_set result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_number_set *> (inPointer) != NULL)
      : (typeid (cPtr_number_set) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_number_set (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_number_set),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_number_set::
reader_loc (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_number_set *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_number_set *) mPointer)->loc ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_number_set::actualTypeName (void) const {
  return "number_set" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_number_set::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__number_set ("number_set", & kTypeDescriptor_GGS_number_set) ;

//---------------------------------------------------------------------------*

GGS_object GGS_number_set::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_number_set * p = NULL ;
    macroMyNew (p, GGS_number_set (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_number_set GGS_number_set::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_number_set result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_number_set * p = dynamic_cast <const GGS_number_set *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_number_set, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_number_set::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_number_set ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_uint32_set'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint32_set::
cPtr_uint32_set (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_number_set (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint32_set * GGS_uint32_set::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_uint32_set) ;
    return (cPtr_uint32_set *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_uint32_set::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@uint32_set:"
           << loc.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uint32_set::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uint32_set::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uint32_set (& typeid (cPtr_uint32_set), & typeid (cPtr_number_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_uint32_set::galgasRTTI (void) const {
  return & gClassInfoFor__uint32_set ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_uint32_set'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_uint32_set ("uint32_set", true, & kTypeDescriptor_GGS_number_set) ;

//---------------------------------------------------------------------------*

GGS_uint32_set::
GGS_uint32_set (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uint32_set::
GGS_uint32_set (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uint32_set GGS_uint32_set::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uint32_set result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uint32_set *> (inPointer) != NULL)
      : (typeid (cPtr_uint32_set) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uint32_set (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uint32_set),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uint32_set::actualTypeName (void) const {
  return "uint32_set" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__uint32_set ("uint32_set", gClassInfoFor__number_set, & kTypeDescriptor_GGS_uint32_set) ;

//---------------------------------------------------------------------------*

GGS_object GGS_uint32_set::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_uint32_set * p = NULL ;
    macroMyNew (p, GGS_uint32_set (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint32_set GGS_uint32_set::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_uint32_set result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_uint32_set * p = dynamic_cast <const GGS_uint32_set *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_uint32_set, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_uint32_set::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_uint32_set ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_sint32_set'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sint32_set::
cPtr_sint32_set (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_number_set (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sint32_set * GGS_sint32_set::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_sint32_set) ;
    return (cPtr_sint32_set *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_sint32_set::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sint32_set:"
           << loc.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sint32_set::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sint32_set::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sint32_set (& typeid (cPtr_sint32_set), & typeid (cPtr_number_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sint32_set::galgasRTTI (void) const {
  return & gClassInfoFor__sint32_set ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_sint32_set'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sint32_set ("sint32_set", true, & kTypeDescriptor_GGS_number_set) ;

//---------------------------------------------------------------------------*

GGS_sint32_set::
GGS_sint32_set (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sint32_set::
GGS_sint32_set (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sint32_set GGS_sint32_set::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sint32_set result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sint32_set *> (inPointer) != NULL)
      : (typeid (cPtr_sint32_set) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sint32_set (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sint32_set),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sint32_set::actualTypeName (void) const {
  return "sint32_set" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sint32_set ("sint32_set", gClassInfoFor__number_set, & kTypeDescriptor_GGS_sint32_set) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sint32_set::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sint32_set * p = NULL ;
    macroMyNew (p, GGS_sint32_set (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint32_set GGS_sint32_set::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sint32_set result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sint32_set * p = dynamic_cast <const GGS_sint32_set *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sint32_set, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sint32_set::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sint32_set ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_uint64_set'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint64_set::
cPtr_uint64_set (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_number_set (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint64_set * GGS_uint64_set::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_uint64_set) ;
    return (cPtr_uint64_set *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_uint64_set::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@uint64_set:"
           << loc.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uint64_set::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uint64_set::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uint64_set (& typeid (cPtr_uint64_set), & typeid (cPtr_number_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_uint64_set::galgasRTTI (void) const {
  return & gClassInfoFor__uint64_set ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_uint64_set'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_uint64_set ("uint64_set", true, & kTypeDescriptor_GGS_number_set) ;

//---------------------------------------------------------------------------*

GGS_uint64_set::
GGS_uint64_set (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uint64_set::
GGS_uint64_set (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uint64_set GGS_uint64_set::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uint64_set result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uint64_set *> (inPointer) != NULL)
      : (typeid (cPtr_uint64_set) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uint64_set (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uint64_set),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uint64_set::actualTypeName (void) const {
  return "uint64_set" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__uint64_set ("uint64_set", gClassInfoFor__number_set, & kTypeDescriptor_GGS_uint64_set) ;

//---------------------------------------------------------------------------*

GGS_object GGS_uint64_set::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_uint64_set * p = NULL ;
    macroMyNew (p, GGS_uint64_set (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64_set GGS_uint64_set::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_uint64_set result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_uint64_set * p = dynamic_cast <const GGS_uint64_set *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_uint64_set, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_uint64_set::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_uint64_set ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_sint64_set'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sint64_set::
cPtr_sint64_set (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_number_set (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sint64_set * GGS_sint64_set::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_sint64_set) ;
    return (cPtr_sint64_set *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_sint64_set::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sint64_set:"
           << loc.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sint64_set::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sint64_set::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sint64_set (& typeid (cPtr_sint64_set), & typeid (cPtr_number_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sint64_set::galgasRTTI (void) const {
  return & gClassInfoFor__sint64_set ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_sint64_set'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sint64_set ("sint64_set", true, & kTypeDescriptor_GGS_number_set) ;

//---------------------------------------------------------------------------*

GGS_sint64_set::
GGS_sint64_set (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sint64_set::
GGS_sint64_set (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sint64_set GGS_sint64_set::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sint64_set result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sint64_set *> (inPointer) != NULL)
      : (typeid (cPtr_sint64_set) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sint64_set (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sint64_set),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sint64_set::actualTypeName (void) const {
  return "sint64_set" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sint64_set ("sint64_set", gClassInfoFor__number_set, & kTypeDescriptor_GGS_sint64_set) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sint64_set::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sint64_set * p = NULL ;
    macroMyNew (p, GGS_sint64_set (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64_set GGS_sint64_set::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sint64_set result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sint64_set * p = dynamic_cast <const GGS_sint64_set *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sint64_set, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sint64_set::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sint64_set ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_float_set'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_float_set::
cPtr_float_set (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_number_set (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_float_set * GGS_float_set::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_float_set) ;
    return (cPtr_float_set *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_float_set::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@float_set:"
           << loc.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_float_set::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_float_set::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_float_set (& typeid (cPtr_float_set), & typeid (cPtr_number_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_float_set::galgasRTTI (void) const {
  return & gClassInfoFor__float_set ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_float_set'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_float_set ("float_set", true, & kTypeDescriptor_GGS_number_set) ;

//---------------------------------------------------------------------------*

GGS_float_set::
GGS_float_set (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_float_set::
GGS_float_set (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_float_set GGS_float_set::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_float_set result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_float_set *> (inPointer) != NULL)
      : (typeid (cPtr_float_set) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_float_set (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_float_set),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_float_set::actualTypeName (void) const {
  return "float_set" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__float_set ("float_set", gClassInfoFor__number_set, & kTypeDescriptor_GGS_float_set) ;

//---------------------------------------------------------------------------*

GGS_object GGS_float_set::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_float_set * p = NULL ;
    macroMyNew (p, GGS_float_set (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_float_set GGS_float_set::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_float_set result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_float_set * p = dynamic_cast <const GGS_float_set *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_float_set, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_float_set::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_float_set ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_uint32_empty_set'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint32_empty_set::
cPtr_uint32_empty_set (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_uint32_set (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint32_empty_set * GGS_uint32_empty_set::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_uint32_empty_set) ;
    return (cPtr_uint32_empty_set *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uint32_empty_set::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_uint32_empty_set * ptr = dynamic_cast <const cPtr_uint32_empty_set *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_uint32_empty_set::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@uint32_empty_set:"
           << loc.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uint32_empty_set::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uint32_empty_set::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uint32_empty_set (& typeid (cPtr_uint32_empty_set), & typeid (cPtr_uint32_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_uint32_empty_set::galgasRTTI (void) const {
  return & gClassInfoFor__uint32_empty_set ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_uint32_empty_set::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_uint32_empty_set (loc COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_uint32_empty_set'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_uint32_empty_set ("uint32_empty_set", true, & kTypeDescriptor_GGS_uint32_set) ;

//---------------------------------------------------------------------------*

GGS_uint32_empty_set::
GGS_uint32_empty_set (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uint32_empty_set::
GGS_uint32_empty_set (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uint32_empty_set GGS_uint32_empty_set::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uint32_empty_set result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uint32_empty_set *> (inPointer) != NULL)
      : (typeid (cPtr_uint32_empty_set) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uint32_empty_set (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uint32_empty_set),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint32_empty_set GGS_uint32_empty_set::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_uint32_empty_set result ;
  macroMyNew (result.mPointer, cPtr_uint32_empty_set (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uint32_empty_set::actualTypeName (void) const {
  return "uint32_empty_set" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__uint32_empty_set ("uint32_empty_set", gClassInfoFor__uint32_set, & kTypeDescriptor_GGS_uint32_empty_set) ;

//---------------------------------------------------------------------------*

GGS_object GGS_uint32_empty_set::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_uint32_empty_set * p = NULL ;
    macroMyNew (p, GGS_uint32_empty_set (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint32_empty_set GGS_uint32_empty_set::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_uint32_empty_set result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_uint32_empty_set * p = dynamic_cast <const GGS_uint32_empty_set *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_uint32_empty_set, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_uint32_empty_set::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_uint32_empty_set ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_sint32_empty_set'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sint32_empty_set::
cPtr_sint32_empty_set (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_sint32_set (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sint32_empty_set * GGS_sint32_empty_set::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_sint32_empty_set) ;
    return (cPtr_sint32_empty_set *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sint32_empty_set::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sint32_empty_set * ptr = dynamic_cast <const cPtr_sint32_empty_set *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sint32_empty_set::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sint32_empty_set:"
           << loc.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sint32_empty_set::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sint32_empty_set::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sint32_empty_set (& typeid (cPtr_sint32_empty_set), & typeid (cPtr_sint32_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sint32_empty_set::galgasRTTI (void) const {
  return & gClassInfoFor__sint32_empty_set ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sint32_empty_set::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sint32_empty_set (loc COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_sint32_empty_set'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sint32_empty_set ("sint32_empty_set", true, & kTypeDescriptor_GGS_sint32_set) ;

//---------------------------------------------------------------------------*

GGS_sint32_empty_set::
GGS_sint32_empty_set (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sint32_empty_set::
GGS_sint32_empty_set (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sint32_empty_set GGS_sint32_empty_set::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sint32_empty_set result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sint32_empty_set *> (inPointer) != NULL)
      : (typeid (cPtr_sint32_empty_set) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sint32_empty_set (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sint32_empty_set),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint32_empty_set GGS_sint32_empty_set::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_sint32_empty_set result ;
  macroMyNew (result.mPointer, cPtr_sint32_empty_set (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sint32_empty_set::actualTypeName (void) const {
  return "sint32_empty_set" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sint32_empty_set ("sint32_empty_set", gClassInfoFor__sint32_set, & kTypeDescriptor_GGS_sint32_empty_set) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sint32_empty_set::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sint32_empty_set * p = NULL ;
    macroMyNew (p, GGS_sint32_empty_set (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint32_empty_set GGS_sint32_empty_set::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sint32_empty_set result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sint32_empty_set * p = dynamic_cast <const GGS_sint32_empty_set *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sint32_empty_set, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sint32_empty_set::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sint32_empty_set ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_uint64_empty_set'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint64_empty_set::
cPtr_uint64_empty_set (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_uint64_set (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint64_empty_set * GGS_uint64_empty_set::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_uint64_empty_set) ;
    return (cPtr_uint64_empty_set *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uint64_empty_set::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_uint64_empty_set * ptr = dynamic_cast <const cPtr_uint64_empty_set *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_uint64_empty_set::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@uint64_empty_set:"
           << loc.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uint64_empty_set::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uint64_empty_set::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uint64_empty_set (& typeid (cPtr_uint64_empty_set), & typeid (cPtr_uint64_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_uint64_empty_set::galgasRTTI (void) const {
  return & gClassInfoFor__uint64_empty_set ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_uint64_empty_set::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_uint64_empty_set (loc COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_uint64_empty_set'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_uint64_empty_set ("uint64_empty_set", true, & kTypeDescriptor_GGS_uint64_set) ;

//---------------------------------------------------------------------------*

GGS_uint64_empty_set::
GGS_uint64_empty_set (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uint64_empty_set::
GGS_uint64_empty_set (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uint64_empty_set GGS_uint64_empty_set::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uint64_empty_set result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uint64_empty_set *> (inPointer) != NULL)
      : (typeid (cPtr_uint64_empty_set) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uint64_empty_set (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uint64_empty_set),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64_empty_set GGS_uint64_empty_set::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_uint64_empty_set result ;
  macroMyNew (result.mPointer, cPtr_uint64_empty_set (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uint64_empty_set::actualTypeName (void) const {
  return "uint64_empty_set" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__uint64_empty_set ("uint64_empty_set", gClassInfoFor__uint64_set, & kTypeDescriptor_GGS_uint64_empty_set) ;

//---------------------------------------------------------------------------*

GGS_object GGS_uint64_empty_set::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_uint64_empty_set * p = NULL ;
    macroMyNew (p, GGS_uint64_empty_set (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64_empty_set GGS_uint64_empty_set::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_uint64_empty_set result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_uint64_empty_set * p = dynamic_cast <const GGS_uint64_empty_set *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_uint64_empty_set, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_uint64_empty_set::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_uint64_empty_set ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_sint64_empty_set'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sint64_empty_set::
cPtr_sint64_empty_set (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_sint64_set (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sint64_empty_set * GGS_sint64_empty_set::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_sint64_empty_set) ;
    return (cPtr_sint64_empty_set *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sint64_empty_set::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sint64_empty_set * ptr = dynamic_cast <const cPtr_sint64_empty_set *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sint64_empty_set::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sint64_empty_set:"
           << loc.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sint64_empty_set::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sint64_empty_set::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sint64_empty_set (& typeid (cPtr_sint64_empty_set), & typeid (cPtr_sint64_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sint64_empty_set::galgasRTTI (void) const {
  return & gClassInfoFor__sint64_empty_set ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sint64_empty_set::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sint64_empty_set (loc COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_sint64_empty_set'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sint64_empty_set ("sint64_empty_set", true, & kTypeDescriptor_GGS_sint64_set) ;

//---------------------------------------------------------------------------*

GGS_sint64_empty_set::
GGS_sint64_empty_set (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sint64_empty_set::
GGS_sint64_empty_set (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sint64_empty_set GGS_sint64_empty_set::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sint64_empty_set result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sint64_empty_set *> (inPointer) != NULL)
      : (typeid (cPtr_sint64_empty_set) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sint64_empty_set (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sint64_empty_set),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64_empty_set GGS_sint64_empty_set::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_sint64_empty_set result ;
  macroMyNew (result.mPointer, cPtr_sint64_empty_set (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sint64_empty_set::actualTypeName (void) const {
  return "sint64_empty_set" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sint64_empty_set ("sint64_empty_set", gClassInfoFor__sint64_set, & kTypeDescriptor_GGS_sint64_empty_set) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sint64_empty_set::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sint64_empty_set * p = NULL ;
    macroMyNew (p, GGS_sint64_empty_set (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64_empty_set GGS_sint64_empty_set::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sint64_empty_set result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sint64_empty_set * p = dynamic_cast <const GGS_sint64_empty_set *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sint64_empty_set, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sint64_empty_set::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sint64_empty_set ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_float_empty_set'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_float_empty_set::
cPtr_float_empty_set (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_float_set (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_float_empty_set * GGS_float_empty_set::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_float_empty_set) ;
    return (cPtr_float_empty_set *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_float_empty_set::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_float_empty_set * ptr = dynamic_cast <const cPtr_float_empty_set *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_float_empty_set::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@float_empty_set:"
           << loc.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_float_empty_set::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_float_empty_set::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_float_empty_set (& typeid (cPtr_float_empty_set), & typeid (cPtr_float_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_float_empty_set::galgasRTTI (void) const {
  return & gClassInfoFor__float_empty_set ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_float_empty_set::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_float_empty_set (loc COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_float_empty_set'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_float_empty_set ("float_empty_set", true, & kTypeDescriptor_GGS_float_set) ;

//---------------------------------------------------------------------------*

GGS_float_empty_set::
GGS_float_empty_set (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_float_empty_set::
GGS_float_empty_set (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_float_empty_set GGS_float_empty_set::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_float_empty_set result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_float_empty_set *> (inPointer) != NULL)
      : (typeid (cPtr_float_empty_set) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_float_empty_set (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_float_empty_set),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_float_empty_set GGS_float_empty_set::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_float_empty_set result ;
  macroMyNew (result.mPointer, cPtr_float_empty_set (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_float_empty_set::actualTypeName (void) const {
  return "float_empty_set" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__float_empty_set ("float_empty_set", gClassInfoFor__float_set, & kTypeDescriptor_GGS_float_empty_set) ;

//---------------------------------------------------------------------------*

GGS_object GGS_float_empty_set::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_float_empty_set * p = NULL ;
    macroMyNew (p, GGS_float_empty_set (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_float_empty_set GGS_float_empty_set::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_float_empty_set result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_float_empty_set * p = dynamic_cast <const GGS_float_empty_set *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_float_empty_set, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_float_empty_set::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_float_empty_set ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_uint32_range'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint32_range::
cPtr_uint32_range (const GGS_location & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_uint & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_uint32_set (argument_0 COMMA_THERE),
min (argument_1),
max (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint32_range * GGS_uint32_range::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_uint32_range) ;
    return (cPtr_uint32_range *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uint32_range::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_uint32_range * ptr = dynamic_cast <const cPtr_uint32_range *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && min.operator_isEqual (ptr->min).boolValue ()
         && max.operator_isEqual (ptr->max).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_uint32_range::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@uint32_range:"
           << loc.reader_description (inIndentation + 1)
           << min.reader_description (inIndentation + 1)
           << max.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uint32_range::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uint32_range::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uint32_range (& typeid (cPtr_uint32_range), & typeid (cPtr_uint32_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_uint32_range::galgasRTTI (void) const {
  return & gClassInfoFor__uint32_range ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_uint32_range::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_uint32_range (loc, min, max COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_uint32_range'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_uint32_range ("uint32_range", true, & kTypeDescriptor_GGS_uint32_set) ;

//---------------------------------------------------------------------------*

GGS_uint32_range::
GGS_uint32_range (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uint32_range::
GGS_uint32_range (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uint32_range GGS_uint32_range::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uint32_range result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uint32_range *> (inPointer) != NULL)
      : (typeid (cPtr_uint32_range) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uint32_range (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uint32_range),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint32_range GGS_uint32_range::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_uint & argument_1,
                 const GGS_uint & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_uint32_range result ;
  macroMyNew (result.mPointer, cPtr_uint32_range (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_uint32_range::
reader_min (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint32_range *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_uint32_range *) mPointer)->min ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_uint32_range::
reader_max (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint32_range *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_uint32_range *) mPointer)->max ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uint32_range::actualTypeName (void) const {
  return "uint32_range" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__uint32_range ("uint32_range", gClassInfoFor__uint32_set, & kTypeDescriptor_GGS_uint32_range) ;

//---------------------------------------------------------------------------*

GGS_object GGS_uint32_range::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_uint32_range * p = NULL ;
    macroMyNew (p, GGS_uint32_range (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint32_range GGS_uint32_range::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_uint32_range result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_uint32_range * p = dynamic_cast <const GGS_uint32_range *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_uint32_range, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_uint32_range::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_uint32_range ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_uint32_list'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint32_list::
cPtr_uint32_list (const GGS_location & argument_0,
                                const GGS_list_uint32 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_uint32_set (argument_0 COMMA_THERE),
li (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint32_list * GGS_uint32_list::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_uint32_list) ;
    return (cPtr_uint32_list *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uint32_list::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_uint32_list * ptr = dynamic_cast <const cPtr_uint32_list *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && li.operator_isEqual (ptr->li).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_uint32_list::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@uint32_list:"
           << loc.reader_description (inIndentation + 1)
           << li.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uint32_list::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uint32_list::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uint32_list (& typeid (cPtr_uint32_list), & typeid (cPtr_uint32_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_uint32_list::galgasRTTI (void) const {
  return & gClassInfoFor__uint32_list ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_uint32_list::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_uint32_list (loc, li COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_uint32_list'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_uint32_list ("uint32_list", true, & kTypeDescriptor_GGS_uint32_set) ;

//---------------------------------------------------------------------------*

GGS_uint32_list::
GGS_uint32_list (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uint32_list::
GGS_uint32_list (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uint32_list GGS_uint32_list::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uint32_list result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uint32_list *> (inPointer) != NULL)
      : (typeid (cPtr_uint32_list) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uint32_list (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uint32_list),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint32_list GGS_uint32_list::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_list_uint32 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_uint32_list result ;
  macroMyNew (result.mPointer, cPtr_uint32_list (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_list_uint32  GGS_uint32_list::
reader_li (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_list_uint32   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint32_list *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_uint32_list *) mPointer)->li ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uint32_list::actualTypeName (void) const {
  return "uint32_list" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__uint32_list ("uint32_list", gClassInfoFor__uint32_set, & kTypeDescriptor_GGS_uint32_list) ;

//---------------------------------------------------------------------------*

GGS_object GGS_uint32_list::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_uint32_list * p = NULL ;
    macroMyNew (p, GGS_uint32_list (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint32_list GGS_uint32_list::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_uint32_list result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_uint32_list * p = dynamic_cast <const GGS_uint32_list *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_uint32_list, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_uint32_list::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_uint32_list ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_sint32_range'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sint32_range::
cPtr_sint32_range (const GGS_location & argument_0,
                                const GGS_sint & argument_1,
                                const GGS_sint & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_sint32_set (argument_0 COMMA_THERE),
min (argument_1),
max (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sint32_range * GGS_sint32_range::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_sint32_range) ;
    return (cPtr_sint32_range *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sint32_range::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sint32_range * ptr = dynamic_cast <const cPtr_sint32_range *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && min.operator_isEqual (ptr->min).boolValue ()
         && max.operator_isEqual (ptr->max).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sint32_range::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sint32_range:"
           << loc.reader_description (inIndentation + 1)
           << min.reader_description (inIndentation + 1)
           << max.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sint32_range::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sint32_range::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sint32_range (& typeid (cPtr_sint32_range), & typeid (cPtr_sint32_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sint32_range::galgasRTTI (void) const {
  return & gClassInfoFor__sint32_range ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sint32_range::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sint32_range (loc, min, max COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_sint32_range'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sint32_range ("sint32_range", true, & kTypeDescriptor_GGS_sint32_set) ;

//---------------------------------------------------------------------------*

GGS_sint32_range::
GGS_sint32_range (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sint32_range::
GGS_sint32_range (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sint32_range GGS_sint32_range::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sint32_range result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sint32_range *> (inPointer) != NULL)
      : (typeid (cPtr_sint32_range) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sint32_range (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sint32_range),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint32_range GGS_sint32_range::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_sint & argument_1,
                 const GGS_sint & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_sint32_range result ;
  macroMyNew (result.mPointer, cPtr_sint32_range (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint  GGS_sint32_range::
reader_min (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint32_range *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sint32_range *) mPointer)->min ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint  GGS_sint32_range::
reader_max (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint32_range *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sint32_range *) mPointer)->max ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sint32_range::actualTypeName (void) const {
  return "sint32_range" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sint32_range ("sint32_range", gClassInfoFor__sint32_set, & kTypeDescriptor_GGS_sint32_range) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sint32_range::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sint32_range * p = NULL ;
    macroMyNew (p, GGS_sint32_range (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint32_range GGS_sint32_range::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sint32_range result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sint32_range * p = dynamic_cast <const GGS_sint32_range *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sint32_range, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sint32_range::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sint32_range ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_sint32_list'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sint32_list::
cPtr_sint32_list (const GGS_location & argument_0,
                                const GGS_list_sint32 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_sint32_set (argument_0 COMMA_THERE),
li (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sint32_list * GGS_sint32_list::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_sint32_list) ;
    return (cPtr_sint32_list *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sint32_list::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sint32_list * ptr = dynamic_cast <const cPtr_sint32_list *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && li.operator_isEqual (ptr->li).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sint32_list::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sint32_list:"
           << loc.reader_description (inIndentation + 1)
           << li.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sint32_list::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sint32_list::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sint32_list (& typeid (cPtr_sint32_list), & typeid (cPtr_sint32_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sint32_list::galgasRTTI (void) const {
  return & gClassInfoFor__sint32_list ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sint32_list::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sint32_list (loc, li COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_sint32_list'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sint32_list ("sint32_list", true, & kTypeDescriptor_GGS_sint32_set) ;

//---------------------------------------------------------------------------*

GGS_sint32_list::
GGS_sint32_list (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sint32_list::
GGS_sint32_list (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sint32_list GGS_sint32_list::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sint32_list result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sint32_list *> (inPointer) != NULL)
      : (typeid (cPtr_sint32_list) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sint32_list (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sint32_list),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint32_list GGS_sint32_list::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_list_sint32 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_sint32_list result ;
  macroMyNew (result.mPointer, cPtr_sint32_list (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_list_sint32  GGS_sint32_list::
reader_li (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_list_sint32   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint32_list *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sint32_list *) mPointer)->li ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sint32_list::actualTypeName (void) const {
  return "sint32_list" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sint32_list ("sint32_list", gClassInfoFor__sint32_set, & kTypeDescriptor_GGS_sint32_list) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sint32_list::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sint32_list * p = NULL ;
    macroMyNew (p, GGS_sint32_list (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint32_list GGS_sint32_list::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sint32_list result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sint32_list * p = dynamic_cast <const GGS_sint32_list *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sint32_list, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sint32_list::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sint32_list ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_uint64_range'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint64_range::
cPtr_uint64_range (const GGS_location & argument_0,
                                const GGS_uint64 & argument_1,
                                const GGS_uint64 & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_uint64_set (argument_0 COMMA_THERE),
min (argument_1),
max (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint64_range * GGS_uint64_range::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_uint64_range) ;
    return (cPtr_uint64_range *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uint64_range::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_uint64_range * ptr = dynamic_cast <const cPtr_uint64_range *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && min.operator_isEqual (ptr->min).boolValue ()
         && max.operator_isEqual (ptr->max).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_uint64_range::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@uint64_range:"
           << loc.reader_description (inIndentation + 1)
           << min.reader_description (inIndentation + 1)
           << max.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uint64_range::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uint64_range::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uint64_range (& typeid (cPtr_uint64_range), & typeid (cPtr_uint64_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_uint64_range::galgasRTTI (void) const {
  return & gClassInfoFor__uint64_range ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_uint64_range::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_uint64_range (loc, min, max COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_uint64_range'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_uint64_range ("uint64_range", true, & kTypeDescriptor_GGS_uint64_set) ;

//---------------------------------------------------------------------------*

GGS_uint64_range::
GGS_uint64_range (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uint64_range::
GGS_uint64_range (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uint64_range GGS_uint64_range::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uint64_range result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uint64_range *> (inPointer) != NULL)
      : (typeid (cPtr_uint64_range) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uint64_range (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uint64_range),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64_range GGS_uint64_range::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_uint64 & argument_1,
                 const GGS_uint64 & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_uint64_range result ;
  macroMyNew (result.mPointer, cPtr_uint64_range (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64  GGS_uint64_range::
reader_min (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint64_range *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_uint64_range *) mPointer)->min ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64  GGS_uint64_range::
reader_max (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint64_range *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_uint64_range *) mPointer)->max ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uint64_range::actualTypeName (void) const {
  return "uint64_range" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__uint64_range ("uint64_range", gClassInfoFor__uint64_set, & kTypeDescriptor_GGS_uint64_range) ;

//---------------------------------------------------------------------------*

GGS_object GGS_uint64_range::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_uint64_range * p = NULL ;
    macroMyNew (p, GGS_uint64_range (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64_range GGS_uint64_range::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_uint64_range result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_uint64_range * p = dynamic_cast <const GGS_uint64_range *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_uint64_range, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_uint64_range::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_uint64_range ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_uint64_list'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint64_list::
cPtr_uint64_list (const GGS_location & argument_0,
                                const GGS_list_uint64 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_uint64_set (argument_0 COMMA_THERE),
li (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint64_list * GGS_uint64_list::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_uint64_list) ;
    return (cPtr_uint64_list *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uint64_list::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_uint64_list * ptr = dynamic_cast <const cPtr_uint64_list *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && li.operator_isEqual (ptr->li).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_uint64_list::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@uint64_list:"
           << loc.reader_description (inIndentation + 1)
           << li.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uint64_list::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uint64_list::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uint64_list (& typeid (cPtr_uint64_list), & typeid (cPtr_uint64_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_uint64_list::galgasRTTI (void) const {
  return & gClassInfoFor__uint64_list ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_uint64_list::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_uint64_list (loc, li COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_uint64_list'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_uint64_list ("uint64_list", true, & kTypeDescriptor_GGS_uint64_set) ;

//---------------------------------------------------------------------------*

GGS_uint64_list::
GGS_uint64_list (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uint64_list::
GGS_uint64_list (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uint64_list GGS_uint64_list::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uint64_list result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uint64_list *> (inPointer) != NULL)
      : (typeid (cPtr_uint64_list) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uint64_list (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uint64_list),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64_list GGS_uint64_list::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_list_uint64 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_uint64_list result ;
  macroMyNew (result.mPointer, cPtr_uint64_list (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_list_uint64  GGS_uint64_list::
reader_li (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_list_uint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint64_list *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_uint64_list *) mPointer)->li ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uint64_list::actualTypeName (void) const {
  return "uint64_list" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__uint64_list ("uint64_list", gClassInfoFor__uint64_set, & kTypeDescriptor_GGS_uint64_list) ;

//---------------------------------------------------------------------------*

GGS_object GGS_uint64_list::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_uint64_list * p = NULL ;
    macroMyNew (p, GGS_uint64_list (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64_list GGS_uint64_list::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_uint64_list result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_uint64_list * p = dynamic_cast <const GGS_uint64_list *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_uint64_list, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_uint64_list::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_uint64_list ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_sint64_range'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sint64_range::
cPtr_sint64_range (const GGS_location & argument_0,
                                const GGS_sint64 & argument_1,
                                const GGS_sint64 & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_sint64_set (argument_0 COMMA_THERE),
min (argument_1),
max (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sint64_range * GGS_sint64_range::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_sint64_range) ;
    return (cPtr_sint64_range *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sint64_range::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sint64_range * ptr = dynamic_cast <const cPtr_sint64_range *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && min.operator_isEqual (ptr->min).boolValue ()
         && max.operator_isEqual (ptr->max).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sint64_range::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sint64_range:"
           << loc.reader_description (inIndentation + 1)
           << min.reader_description (inIndentation + 1)
           << max.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sint64_range::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sint64_range::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sint64_range (& typeid (cPtr_sint64_range), & typeid (cPtr_sint64_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sint64_range::galgasRTTI (void) const {
  return & gClassInfoFor__sint64_range ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sint64_range::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sint64_range (loc, min, max COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_sint64_range'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sint64_range ("sint64_range", true, & kTypeDescriptor_GGS_sint64_set) ;

//---------------------------------------------------------------------------*

GGS_sint64_range::
GGS_sint64_range (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sint64_range::
GGS_sint64_range (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sint64_range GGS_sint64_range::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sint64_range result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sint64_range *> (inPointer) != NULL)
      : (typeid (cPtr_sint64_range) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sint64_range (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sint64_range),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64_range GGS_sint64_range::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_sint64 & argument_1,
                 const GGS_sint64 & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_sint64_range result ;
  macroMyNew (result.mPointer, cPtr_sint64_range (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64  GGS_sint64_range::
reader_min (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint64_range *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sint64_range *) mPointer)->min ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64  GGS_sint64_range::
reader_max (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint64_range *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sint64_range *) mPointer)->max ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sint64_range::actualTypeName (void) const {
  return "sint64_range" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sint64_range ("sint64_range", gClassInfoFor__sint64_set, & kTypeDescriptor_GGS_sint64_range) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sint64_range::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sint64_range * p = NULL ;
    macroMyNew (p, GGS_sint64_range (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64_range GGS_sint64_range::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sint64_range result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sint64_range * p = dynamic_cast <const GGS_sint64_range *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sint64_range, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sint64_range::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sint64_range ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_sint64_list'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sint64_list::
cPtr_sint64_list (const GGS_location & argument_0,
                                const GGS_list_sint64 & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_sint64_set (argument_0 COMMA_THERE),
li (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sint64_list * GGS_sint64_list::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_sint64_list) ;
    return (cPtr_sint64_list *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sint64_list::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sint64_list * ptr = dynamic_cast <const cPtr_sint64_list *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && li.operator_isEqual (ptr->li).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sint64_list::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sint64_list:"
           << loc.reader_description (inIndentation + 1)
           << li.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sint64_list::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sint64_list::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sint64_list (& typeid (cPtr_sint64_list), & typeid (cPtr_sint64_set), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sint64_list::galgasRTTI (void) const {
  return & gClassInfoFor__sint64_list ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sint64_list::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sint64_list (loc, li COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_sint64_list'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sint64_list ("sint64_list", true, & kTypeDescriptor_GGS_sint64_set) ;

//---------------------------------------------------------------------------*

GGS_sint64_list::
GGS_sint64_list (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sint64_list::
GGS_sint64_list (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sint64_list GGS_sint64_list::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sint64_list result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sint64_list *> (inPointer) != NULL)
      : (typeid (cPtr_sint64_list) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sint64_list (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sint64_list),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64_list GGS_sint64_list::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_list_sint64 & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_sint64_list result ;
  macroMyNew (result.mPointer, cPtr_sint64_list (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_list_sint64  GGS_sint64_list::
reader_li (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_list_sint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint64_list *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sint64_list *) mPointer)->li ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sint64_list::actualTypeName (void) const {
  return "sint64_list" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sint64_list ("sint64_list", gClassInfoFor__sint64_set, & kTypeDescriptor_GGS_sint64_list) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sint64_list::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sint64_list * p = NULL ;
    macroMyNew (p, GGS_sint64_list (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64_list GGS_sint64_list::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sint64_list result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sint64_list * p = dynamic_cast <const GGS_sint64_list *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sint64_list, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sint64_list::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sint64_list ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_imp_type'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_imp_type::
cPtr_imp_type (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
loc (argument_0),
desc (argument_1),
multiple (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_imp_type * GGS_imp_type::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_imp_type) ;
    return (cPtr_imp_type *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_imp_type::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@imp_type:"
           << loc.reader_description (inIndentation + 1)
           << desc.reader_description (inIndentation + 1)
           << multiple.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_imp_type::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_imp_type::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_imp_type (& typeid (cPtr_imp_type), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_imp_type::galgasRTTI (void) const {
  return & gClassInfoFor__imp_type ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_imp_type'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_imp_type ("imp_type", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_imp_type::
GGS_imp_type (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_imp_type::
GGS_imp_type (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_imp_type GGS_imp_type::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_imp_type result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_imp_type *> (inPointer) != NULL)
      : (typeid (cPtr_imp_type) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_imp_type (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_imp_type),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_imp_type::
reader_loc (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_imp_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_imp_type *) mPointer)->loc ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_imp_type::
reader_desc (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_imp_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_imp_type *) mPointer)->desc ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_imp_type::
reader_multiple (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_imp_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_imp_type *) mPointer)->multiple ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_imp_type::actualTypeName (void) const {
  return "imp_type" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_imp_type::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__imp_type ("imp_type", & kTypeDescriptor_GGS_imp_type) ;

//---------------------------------------------------------------------------*

GGS_object GGS_imp_type::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_imp_type * p = NULL ;
    macroMyNew (p, GGS_imp_type (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_imp_type GGS_imp_type::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_imp_type result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_imp_type * p = dynamic_cast <const GGS_imp_type *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_imp_type, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_imp_type::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_imp_type ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_imp_sca_type'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_imp_sca_type::
cPtr_imp_sca_type (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_imp_type (argument_0, argument_1, argument_2 COMMA_THERE),
with_auto (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_imp_sca_type * GGS_imp_sca_type::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_imp_sca_type) ;
    return (cPtr_imp_sca_type *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_imp_sca_type::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@imp_sca_type:"
           << loc.reader_description (inIndentation + 1)
           << desc.reader_description (inIndentation + 1)
           << multiple.reader_description (inIndentation + 1)
           << with_auto.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_imp_sca_type::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_imp_sca_type::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_imp_sca_type (& typeid (cPtr_imp_sca_type), & typeid (cPtr_imp_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_imp_sca_type::galgasRTTI (void) const {
  return & gClassInfoFor__imp_sca_type ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_imp_sca_type'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_imp_sca_type ("imp_sca_type", true, & kTypeDescriptor_GGS_imp_type) ;

//---------------------------------------------------------------------------*

GGS_imp_sca_type::
GGS_imp_sca_type (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_imp_sca_type::
GGS_imp_sca_type (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_imp_sca_type GGS_imp_sca_type::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_imp_sca_type result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_imp_sca_type *> (inPointer) != NULL)
      : (typeid (cPtr_imp_sca_type) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_imp_sca_type (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_imp_sca_type),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_imp_sca_type::
reader_with_auto (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_imp_sca_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_imp_sca_type *) mPointer)->with_auto ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_imp_sca_type::actualTypeName (void) const {
  return "imp_sca_type" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__imp_sca_type ("imp_sca_type", gClassInfoFor__imp_type, & kTypeDescriptor_GGS_imp_sca_type) ;

//---------------------------------------------------------------------------*

GGS_object GGS_imp_sca_type::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_imp_sca_type * p = NULL ;
    macroMyNew (p, GGS_imp_sca_type (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_imp_sca_type GGS_imp_sca_type::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_imp_sca_type result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_imp_sca_type * p = dynamic_cast <const GGS_imp_sca_type *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_imp_sca_type, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_imp_sca_type::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_imp_sca_type ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_imp_obj_ref'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_imp_obj_ref::
cPtr_imp_obj_ref (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_imp_type (argument_0, argument_1, argument_2 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_imp_obj_ref * GGS_imp_obj_ref::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_imp_obj_ref) ;
    return (cPtr_imp_obj_ref *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_imp_obj_ref::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@imp_obj_ref:"
           << loc.reader_description (inIndentation + 1)
           << desc.reader_description (inIndentation + 1)
           << multiple.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_imp_obj_ref::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_imp_obj_ref::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_imp_obj_ref (& typeid (cPtr_imp_obj_ref), & typeid (cPtr_imp_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_imp_obj_ref::galgasRTTI (void) const {
  return & gClassInfoFor__imp_obj_ref ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_imp_obj_ref'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_imp_obj_ref ("imp_obj_ref", true, & kTypeDescriptor_GGS_imp_type) ;

//---------------------------------------------------------------------------*

GGS_imp_obj_ref::
GGS_imp_obj_ref (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_imp_obj_ref::
GGS_imp_obj_ref (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_imp_obj_ref GGS_imp_obj_ref::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_imp_obj_ref result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_imp_obj_ref *> (inPointer) != NULL)
      : (typeid (cPtr_imp_obj_ref) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_imp_obj_ref (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_imp_obj_ref),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_imp_obj_ref::actualTypeName (void) const {
  return "imp_obj_ref" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__imp_obj_ref ("imp_obj_ref", gClassInfoFor__imp_type, & kTypeDescriptor_GGS_imp_obj_ref) ;

//---------------------------------------------------------------------------*

GGS_object GGS_imp_obj_ref::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_imp_obj_ref * p = NULL ;
    macroMyNew (p, GGS_imp_obj_ref (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_imp_obj_ref GGS_imp_obj_ref::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_imp_obj_ref result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_imp_obj_ref * p = dynamic_cast <const GGS_imp_obj_ref *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_imp_obj_ref, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_imp_obj_ref::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_imp_obj_ref ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_void_type'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_void_type::
cPtr_void_type (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_imp_type (argument_0, argument_1, argument_2 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_void_type * GGS_void_type::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_void_type) ;
    return (cPtr_void_type *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_void_type::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_void_type * ptr = dynamic_cast <const cPtr_void_type *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && desc.operator_isEqual (ptr->desc).boolValue ()
         && multiple.operator_isEqual (ptr->multiple).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_void_type::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@void_type:"
           << loc.reader_description (inIndentation + 1)
           << desc.reader_description (inIndentation + 1)
           << multiple.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_void_type::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_void_type::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_void_type (& typeid (cPtr_void_type), & typeid (cPtr_imp_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_void_type::galgasRTTI (void) const {
  return & gClassInfoFor__void_type ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_void_type::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_void_type (loc, desc, multiple COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_void_type'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_void_type ("void_type", true, & kTypeDescriptor_GGS_imp_type) ;

//---------------------------------------------------------------------------*

GGS_void_type::
GGS_void_type (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_void_type::
GGS_void_type (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_void_type GGS_void_type::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_void_type result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_void_type *> (inPointer) != NULL)
      : (typeid (cPtr_void_type) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_void_type (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_void_type),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_type GGS_void_type::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_void_type result ;
  macroMyNew (result.mPointer, cPtr_void_type (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_void_type::actualTypeName (void) const {
  return "void_type" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__void_type ("void_type", gClassInfoFor__imp_type, & kTypeDescriptor_GGS_void_type) ;

//---------------------------------------------------------------------------*

GGS_object GGS_void_type::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_void_type * p = NULL ;
    macroMyNew (p, GGS_void_type (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_void_type GGS_void_type::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_void_type result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_void_type * p = dynamic_cast <const GGS_void_type *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_void_type, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_void_type::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_void_type ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_uint32_type'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint32_type::
cPtr_uint32_type (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_bool& argument_3,
                                const GGS_uint32_class & argument_4,
                                const GGS_uint32_set & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_imp_sca_type (argument_0, argument_1, argument_2, argument_3 COMMA_THERE),
def_val (argument_4),
set (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint32_type * GGS_uint32_type::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_uint32_type) ;
    return (cPtr_uint32_type *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uint32_type::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_uint32_type * ptr = dynamic_cast <const cPtr_uint32_type *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && desc.operator_isEqual (ptr->desc).boolValue ()
         && multiple.operator_isEqual (ptr->multiple).boolValue ()
         && with_auto.operator_isEqual (ptr->with_auto).boolValue ()
         && def_val.operator_isEqual (ptr->def_val).boolValue ()
         && set.operator_isEqual (ptr->set).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_uint32_type::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@uint32_type:"
           << loc.reader_description (inIndentation + 1)
           << desc.reader_description (inIndentation + 1)
           << multiple.reader_description (inIndentation + 1)
           << with_auto.reader_description (inIndentation + 1)
           << def_val.reader_description (inIndentation + 1)
           << set.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uint32_type::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uint32_type::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uint32_type (& typeid (cPtr_uint32_type), & typeid (cPtr_imp_sca_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_uint32_type::galgasRTTI (void) const {
  return & gClassInfoFor__uint32_type ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_uint32_type::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_uint32_type (loc, desc, multiple, with_auto, def_val, set COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_uint32_type'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_uint32_type ("uint32_type", true, & kTypeDescriptor_GGS_imp_sca_type) ;

//---------------------------------------------------------------------------*

GGS_uint32_type::
GGS_uint32_type (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uint32_type::
GGS_uint32_type (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uint32_type GGS_uint32_type::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uint32_type result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uint32_type *> (inPointer) != NULL)
      : (typeid (cPtr_uint32_type) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uint32_type (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uint32_type),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint32_type GGS_uint32_type::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_bool& argument_2,
                 const GGS_bool& argument_3,
                 const GGS_uint32_class & argument_4,
                 const GGS_uint32_set & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_uint32_type result ;
  macroMyNew (result.mPointer, cPtr_uint32_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint32_class  GGS_uint32_type::
reader_def_val (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint32_class   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint32_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_uint32_type *) mPointer)->def_val ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint32_set  GGS_uint32_type::
reader_set (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint32_set   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint32_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_uint32_type *) mPointer)->set ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uint32_type::actualTypeName (void) const {
  return "uint32_type" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__uint32_type ("uint32_type", gClassInfoFor__imp_sca_type, & kTypeDescriptor_GGS_uint32_type) ;

//---------------------------------------------------------------------------*

GGS_object GGS_uint32_type::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_uint32_type * p = NULL ;
    macroMyNew (p, GGS_uint32_type (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint32_type GGS_uint32_type::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_uint32_type result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_uint32_type * p = dynamic_cast <const GGS_uint32_type *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_uint32_type, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_uint32_type::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_uint32_type ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_sint32_type'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sint32_type::
cPtr_sint32_type (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_bool& argument_3,
                                const GGS_sint32_class & argument_4,
                                const GGS_sint32_set & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_imp_sca_type (argument_0, argument_1, argument_2, argument_3 COMMA_THERE),
def_val (argument_4),
set (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sint32_type * GGS_sint32_type::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_sint32_type) ;
    return (cPtr_sint32_type *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sint32_type::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sint32_type * ptr = dynamic_cast <const cPtr_sint32_type *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && desc.operator_isEqual (ptr->desc).boolValue ()
         && multiple.operator_isEqual (ptr->multiple).boolValue ()
         && with_auto.operator_isEqual (ptr->with_auto).boolValue ()
         && def_val.operator_isEqual (ptr->def_val).boolValue ()
         && set.operator_isEqual (ptr->set).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sint32_type::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sint32_type:"
           << loc.reader_description (inIndentation + 1)
           << desc.reader_description (inIndentation + 1)
           << multiple.reader_description (inIndentation + 1)
           << with_auto.reader_description (inIndentation + 1)
           << def_val.reader_description (inIndentation + 1)
           << set.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sint32_type::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sint32_type::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sint32_type (& typeid (cPtr_sint32_type), & typeid (cPtr_imp_sca_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sint32_type::galgasRTTI (void) const {
  return & gClassInfoFor__sint32_type ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sint32_type::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sint32_type (loc, desc, multiple, with_auto, def_val, set COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_sint32_type'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sint32_type ("sint32_type", true, & kTypeDescriptor_GGS_imp_sca_type) ;

//---------------------------------------------------------------------------*

GGS_sint32_type::
GGS_sint32_type (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sint32_type::
GGS_sint32_type (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sint32_type GGS_sint32_type::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sint32_type result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sint32_type *> (inPointer) != NULL)
      : (typeid (cPtr_sint32_type) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sint32_type (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sint32_type),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint32_type GGS_sint32_type::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_bool& argument_2,
                 const GGS_bool& argument_3,
                 const GGS_sint32_class & argument_4,
                 const GGS_sint32_set & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_sint32_type result ;
  macroMyNew (result.mPointer, cPtr_sint32_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint32_class  GGS_sint32_type::
reader_def_val (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sint32_class   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint32_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sint32_type *) mPointer)->def_val ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint32_set  GGS_sint32_type::
reader_set (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sint32_set   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint32_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sint32_type *) mPointer)->set ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sint32_type::actualTypeName (void) const {
  return "sint32_type" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sint32_type ("sint32_type", gClassInfoFor__imp_sca_type, & kTypeDescriptor_GGS_sint32_type) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sint32_type::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sint32_type * p = NULL ;
    macroMyNew (p, GGS_sint32_type (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint32_type GGS_sint32_type::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sint32_type result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sint32_type * p = dynamic_cast <const GGS_sint32_type *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sint32_type, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sint32_type::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sint32_type ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_uint64_type'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint64_type::
cPtr_uint64_type (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_bool& argument_3,
                                const GGS_uint64_class & argument_4,
                                const GGS_uint64_set & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_imp_sca_type (argument_0, argument_1, argument_2, argument_3 COMMA_THERE),
def_val (argument_4),
set (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint64_type * GGS_uint64_type::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_uint64_type) ;
    return (cPtr_uint64_type *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uint64_type::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_uint64_type * ptr = dynamic_cast <const cPtr_uint64_type *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && desc.operator_isEqual (ptr->desc).boolValue ()
         && multiple.operator_isEqual (ptr->multiple).boolValue ()
         && with_auto.operator_isEqual (ptr->with_auto).boolValue ()
         && def_val.operator_isEqual (ptr->def_val).boolValue ()
         && set.operator_isEqual (ptr->set).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_uint64_type::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@uint64_type:"
           << loc.reader_description (inIndentation + 1)
           << desc.reader_description (inIndentation + 1)
           << multiple.reader_description (inIndentation + 1)
           << with_auto.reader_description (inIndentation + 1)
           << def_val.reader_description (inIndentation + 1)
           << set.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uint64_type::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uint64_type::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uint64_type (& typeid (cPtr_uint64_type), & typeid (cPtr_imp_sca_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_uint64_type::galgasRTTI (void) const {
  return & gClassInfoFor__uint64_type ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_uint64_type::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_uint64_type (loc, desc, multiple, with_auto, def_val, set COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_uint64_type'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_uint64_type ("uint64_type", true, & kTypeDescriptor_GGS_imp_sca_type) ;

//---------------------------------------------------------------------------*

GGS_uint64_type::
GGS_uint64_type (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uint64_type::
GGS_uint64_type (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uint64_type GGS_uint64_type::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uint64_type result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uint64_type *> (inPointer) != NULL)
      : (typeid (cPtr_uint64_type) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uint64_type (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uint64_type),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64_type GGS_uint64_type::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_bool& argument_2,
                 const GGS_bool& argument_3,
                 const GGS_uint64_class & argument_4,
                 const GGS_uint64_set & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_uint64_type result ;
  macroMyNew (result.mPointer, cPtr_uint64_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64_class  GGS_uint64_type::
reader_def_val (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint64_class   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint64_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_uint64_type *) mPointer)->def_val ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64_set  GGS_uint64_type::
reader_set (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint64_set   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_uint64_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_uint64_type *) mPointer)->set ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uint64_type::actualTypeName (void) const {
  return "uint64_type" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__uint64_type ("uint64_type", gClassInfoFor__imp_sca_type, & kTypeDescriptor_GGS_uint64_type) ;

//---------------------------------------------------------------------------*

GGS_object GGS_uint64_type::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_uint64_type * p = NULL ;
    macroMyNew (p, GGS_uint64_type (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64_type GGS_uint64_type::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_uint64_type result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_uint64_type * p = dynamic_cast <const GGS_uint64_type *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_uint64_type, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_uint64_type::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_uint64_type ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_sint64_type'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sint64_type::
cPtr_sint64_type (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_bool& argument_3,
                                const GGS_sint64_class & argument_4,
                                const GGS_sint64_set & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_imp_sca_type (argument_0, argument_1, argument_2, argument_3 COMMA_THERE),
def_val (argument_4),
set (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sint64_type * GGS_sint64_type::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_sint64_type) ;
    return (cPtr_sint64_type *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sint64_type::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sint64_type * ptr = dynamic_cast <const cPtr_sint64_type *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = loc.operator_isEqual (ptr->loc).boolValue ()
         && desc.operator_isEqual (ptr->desc).boolValue ()
         && multiple.operator_isEqual (ptr->multiple).boolValue ()
         && with_auto.operator_isEqual (ptr->with_auto).boolValue ()
         && def_val.operator_isEqual (ptr->def_val).boolValue ()
         && set.operator_isEqual (ptr->set).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sint64_type::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sint64_type:"
           << loc.reader_description (inIndentation + 1)
           << desc.reader_description (inIndentation + 1)
           << multiple.reader_description (inIndentation + 1)
           << with_auto.reader_description (inIndentation + 1)
           << def_val.reader_description (inIndentation + 1)
           << set.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sint64_type::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sint64_type::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sint64_type (& typeid (cPtr_sint64_type), & typeid (cPtr_imp_sca_type), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sint64_type::galgasRTTI (void) const {
  return & gClassInfoFor__sint64_type ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sint64_type::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sint64_type (loc, desc, multiple, with_auto, def_val, set COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_sint64_type'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sint64_type ("sint64_type", true, & kTypeDescriptor_GGS_imp_sca_type) ;

//---------------------------------------------------------------------------*

GGS_sint64_type::
GGS_sint64_type (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sint64_type::
GGS_sint64_type (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sint64_type GGS_sint64_type::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sint64_type result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sint64_type *> (inPointer) != NULL)
      : (typeid (cPtr_sint64_type) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sint64_type (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sint64_type),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64_type GGS_sint64_type::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_bool& argument_2,
                 const GGS_bool& argument_3,
                 const GGS_sint64_class & argument_4,
                 const GGS_sint64_set & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_sint64_type result ;
  macroMyNew (result.mPointer, cPtr_sint64_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64_class  GGS_sint64_type::
reader_def_val (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sint64_class   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint64_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sint64_type *) mPointer)->def_val ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64_set  GGS_sint64_type::
reader_set (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sint64_set   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sint64_type *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sint64_type *) mPointer)->set ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sint64_type::actualTypeName (void) const {
  return "sint64_type" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sint64_type ("sint64_type", gClassInfoFor__imp_sca_type, & kTypeDescriptor_GGS_sint64_type) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sint64_type::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sint64_type * p = NULL ;
    macroMyNew (p, GGS_sint64_type (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64_type GGS_sint64_type::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sint64_type result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sint64_type * p = dynamic_cast <const GGS_sint64_type *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sint64_type, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sint64_type::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sint64_type ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_ident_map'                             *
//                                                                           *
//---------------------------------------------------------------------------*

e_ident_map::e_ident_map (void) :
value () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map '@ident_map'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_ident_map ("ident_map", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_ident_map::
elementOf_GGS_ident_map (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_ident_map & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ident_map::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.value.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_ident_map::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_ident_map * ptr = dynamic_cast <const elementOf_GGS_ident_map *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.value.operator_isEqual (ptr->mInfo.value)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_ident_map::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_ident_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_ident_map * info = (e_ident_map *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_ident_map::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_ident_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_ident_map * info = (e_ident_map *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_ident_map GGS_ident_map::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ident_map result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ident_map::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_ident_map info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ident_map::
operator_isEqual (const GGS_ident_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ident_map::
operator_isNotEqual (const GGS_ident_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_ident_map::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_ident_map::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_basic_type & inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_ident_map info  ;
    info.value = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ident_map::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_basic_type   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.value ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_ident_map::kSearchMessage_get [] = {
  TO_UNICODE ('I'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_ident_map::
method_get (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_basic_type   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_get,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_ident_map::kInsertMessage_put [] = {
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('u'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_ident_map::
modifier_put (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_basic_type & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_put,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_ident_map GGS_ident_map::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_ident_map & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ident_map result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ident_map GGS_ident_map::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ident_map result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ident_map::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @ident_map " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_basic_type  & GGS_ident_map::cEnumerator::_value (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.value ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_ident_map::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_ident_map * p = NULL ;
    macroMyNew (p, GGS_ident_map (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ident_map GGS_ident_map::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_ident_map result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_ident_map * p = dynamic_cast <const GGS_ident_map *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_ident_map, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_ident_map::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_ident_map ;
}

//---------------------------------------------------------------------------*

GGS_ident_map GGS_ident_map::constructor_mapWithKeyAndValue (C_Compiler & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_basic_type & inValue0
                                             COMMA_LOCATION_ARGS) {
  GGS_ident_map result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_stringMap'                             *
//                                                                           *
//---------------------------------------------------------------------------*

e_stringMap::e_stringMap (void) :
value () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map '@stringMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_stringMap ("stringMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_stringMap::
elementOf_GGS_stringMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_stringMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_stringMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.value.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_stringMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_stringMap * ptr = dynamic_cast <const elementOf_GGS_stringMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.value.operator_isEqual (ptr->mInfo.value)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_stringMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_stringMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_stringMap * info = (e_stringMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_stringMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_stringMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_stringMap * info = (e_stringMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_stringMap GGS_stringMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_stringMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_stringMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_stringMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_stringMap::
operator_isEqual (const GGS_stringMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_stringMap::
operator_isNotEqual (const GGS_stringMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_stringMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_stringMap::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_string& inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_stringMap info  ;
    info.value = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_stringMap::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_string  & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.value ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_stringMap::kSearchMessage_get [] = {
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('g'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE (' '),
  TO_UNICODE ('l'),
  TO_UNICODE ('k'),
  TO_UNICODE ('e'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_stringMap::
method_get (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_string  & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_get,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_stringMap::kInsertMessage_put [] = {
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('g'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE (' '),
  TO_UNICODE ('l'),
  TO_UNICODE ('k'),
  TO_UNICODE ('e'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('u'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_stringMap::
modifier_put (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_string& inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_put,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_stringMap GGS_stringMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_stringMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_stringMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringMap GGS_stringMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_stringMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_stringMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @stringMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_stringMap::cEnumerator::_value (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.value ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_stringMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_stringMap * p = NULL ;
    macroMyNew (p, GGS_stringMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringMap GGS_stringMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_stringMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_stringMap * p = dynamic_cast <const GGS_stringMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_stringMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_stringMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_stringMap ;
}

//---------------------------------------------------------------------------*

GGS_stringMap GGS_stringMap::constructor_mapWithKeyAndValue (C_Compiler & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_string& inValue0
                                             COMMA_LOCATION_ARGS) {
  GGS_stringMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_lstringMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_lstringMap::e_lstringMap (void) :
value () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@lstringMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lstringMap ("lstringMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_lstringMap::
elementOf_GGS_lstringMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_lstringMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lstringMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.value.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lstringMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_lstringMap * ptr = dynamic_cast <const elementOf_GGS_lstringMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.value.operator_isEqual (ptr->mInfo.value)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_lstringMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_lstringMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_lstringMap * info = (e_lstringMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_lstringMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_lstringMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_lstringMap * info = (e_lstringMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_lstringMap GGS_lstringMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lstringMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lstringMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_lstringMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_lstringMap::
operator_isEqual (const GGS_lstringMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_lstringMap::
operator_isNotEqual (const GGS_lstringMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_lstringMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_lstringMap::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring & inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_lstringMap info  ;
    info.value = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lstringMap::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.value ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_lstringMap::kSearchMessage_get [] = {
  TO_UNICODE ('l'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('g'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE (' '),
  TO_UNICODE ('l'),
  TO_UNICODE ('k'),
  TO_UNICODE ('e'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_lstringMap::
method_get (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_get,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_lstringMap::kInsertMessage_put [] = {
  TO_UNICODE ('l'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('g'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE (' '),
  TO_UNICODE ('l'),
  TO_UNICODE ('k'),
  TO_UNICODE ('e'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('u'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_lstringMap::
modifier_put (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_put,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_lstringMap GGS_lstringMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_lstringMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lstringMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringMap GGS_lstringMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lstringMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @lstringMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_lstringMap::cEnumerator::_value (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.value ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_lstringMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lstringMap * p = NULL ;
    macroMyNew (p, GGS_lstringMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringMap GGS_lstringMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lstringMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lstringMap * p = dynamic_cast <const GGS_lstringMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lstringMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lstringMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lstringMap ;
}

//---------------------------------------------------------------------------*

GGS_lstringMap GGS_lstringMap::constructor_mapWithKeyAndValue (C_Compiler & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_lstring & inValue0
                                             COMMA_LOCATION_ARGS) {
  GGS_lstringMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_prefix_map'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_prefix_map::e_prefix_map (void) :
prefix (),
tag_to_rep () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@prefix_map'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_prefix_map ("prefix_map", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_prefix_map::
elementOf_GGS_prefix_map (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_prefix_map & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_prefix_map::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.prefix.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.tag_to_rep.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_prefix_map::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_prefix_map * ptr = dynamic_cast <const elementOf_GGS_prefix_map *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.prefix.operator_isEqual (ptr->mInfo.prefix)).boolValue ()
           && (mInfo.tag_to_rep.operator_isEqual (ptr->mInfo.tag_to_rep)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_prefix_map::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_prefix_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_prefix_map * info = (e_prefix_map *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_prefix_map::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_prefix_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_prefix_map * info = (e_prefix_map *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_prefix_map GGS_prefix_map::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_prefix_map result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_prefix_map::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_prefix_map info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_prefix_map::
operator_isEqual (const GGS_prefix_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_prefix_map::
operator_isNotEqual (const GGS_prefix_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_prefix_map::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_prefix_map::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_string& inParameter0,
               const GGS_string& inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_prefix_map info  ;
    info.prefix = inParameter0 ;
    info.tag_to_rep = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_prefix_map::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_string  & outParameter0,
               GGS_string  & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.prefix ;
    outParameter1 = node->mInfo.tag_to_rep ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_prefix_map::kSearchMessage_prefix [] = {
  TO_UNICODE ('p'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('x'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_prefix_map::
method_prefix (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_string  & outParameter0,
                                GGS_string  & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_prefix,
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_prefix_map::kInsertMessage_add [] = {
  TO_UNICODE ('p'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('x'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('u'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_prefix_map::kInsertMessage_insert_prefix [] = {
  TO_UNICODE ('p'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('x'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('u'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('i'),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_prefix_map::
modifier_add (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_string& inParameter0,
                                const GGS_string& inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_add,
                 inKey,
                 inParameter0,
                 inParameter1,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_prefix_map::
modifier_insert_prefix (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_string& inParameter0,
                                const GGS_string& inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insert_prefix,
                 inKey,
                 inParameter0,
                 inParameter1,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_prefix_map GGS_prefix_map::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_prefix_map & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_prefix_map result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_prefix_map GGS_prefix_map::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_prefix_map result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_prefix_map::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @prefix_map " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_prefix_map::cEnumerator::_prefix (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.prefix ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_prefix_map::cEnumerator::_tag_to_rep (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.tag_to_rep ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_prefix_map::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_prefix_map * p = NULL ;
    macroMyNew (p, GGS_prefix_map (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_prefix_map GGS_prefix_map::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_prefix_map result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_prefix_map * p = dynamic_cast <const GGS_prefix_map *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_prefix_map, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_prefix_map::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_prefix_map ;
}

//---------------------------------------------------------------------------*

GGS_prefix_map GGS_prefix_map::constructor_mapWithKeyAndValue (C_Compiler & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_string& inValue0,
                                             const GGS_string& inValue1
                                             COMMA_LOCATION_ARGS) {
  GGS_prefix_map result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        inValue1,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_stringset_map'                           *
//                                                                           *
//---------------------------------------------------------------------------*

e_stringset_map::e_stringset_map (void) :
ids () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map '@stringset_map'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_stringset_map ("stringset_map", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_stringset_map::
elementOf_GGS_stringset_map (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_stringset_map & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_stringset_map::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.ids.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_stringset_map::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_stringset_map * ptr = dynamic_cast <const elementOf_GGS_stringset_map *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.ids.operator_isEqual (ptr->mInfo.ids)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_stringset_map::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_stringset_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_stringset_map * info = (e_stringset_map *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_stringset_map::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_stringset_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_stringset_map * info = (e_stringset_map *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_stringset_map GGS_stringset_map::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_stringset_map result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_stringset_map::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_stringset_map info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_stringset_map::
operator_isEqual (const GGS_stringset_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_stringset_map::
operator_isNotEqual (const GGS_stringset_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_stringset_map::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_stringset_map::
removeElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_stringset & outParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  AC_galgas_map_element * removedElement = NULL ;
  PMSInt32 elementID = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    removedElement = internalRemove (inKey) ;
    if (removedElement == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
      outParameter0.drop () ;
    }else{
      cElement * ptr = (cElement *) removedElement ;
      elementID = ptr->mID ;
      outParameter0 = ptr->mInfo.ids ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
  macroMyDelete (removedElement) ;
}

//---------------------------------------------------------------------------*

void GGS_stringset_map::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_stringset & inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_stringset_map info  ;
    info.ids = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_stringset_map::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_stringset   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.ids ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_stringset_map::kSearchMessage_get [] = {
  TO_UNICODE ('K'),
  TO_UNICODE ('e'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_stringset_map::
method_get (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_stringset   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_get,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_stringset_map::kRemoveMessage_delete [] = {
  TO_UNICODE ('K'),
  TO_UNICODE ('e'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_stringset_map::
modifier_delete (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_stringset & outParameter0 COMMA_LOCATION_ARGS) {
  removeElement (inLexique,
                  kRemoveMessage_delete,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_stringset_map::kInsertMessage_add [] = {
  TO_UNICODE ('K'),
  TO_UNICODE ('e'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('u'),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_stringset_map::
modifier_add (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_stringset & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_add,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_stringset_map GGS_stringset_map::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_stringset_map & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_stringset_map result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset_map GGS_stringset_map::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_stringset_map result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_stringset_map::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @stringset_map " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_stringset  & GGS_stringset_map::cEnumerator::_ids (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.ids ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_stringset_map::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_stringset_map * p = NULL ;
    macroMyNew (p, GGS_stringset_map (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset_map GGS_stringset_map::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_stringset_map result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_stringset_map * p = dynamic_cast <const GGS_stringset_map *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_stringset_map, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_stringset_map::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_stringset_map ;
}

//---------------------------------------------------------------------------*

GGS_stringset_map GGS_stringset_map::constructor_mapWithKeyAndValue (C_Compiler & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_stringset & inValue0
                                             COMMA_LOCATION_ARGS) {
  GGS_stringset_map result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Element of list '@ident_list'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_ident_list::
elementOf_GGS_ident_list (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
obj_name (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_ident_list::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_ident_list * ptr = dynamic_cast <const elementOf_GGS_ident_list *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = obj_name.operator_isEqual (ptr->obj_name).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ident_list::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << obj_name.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            List '@ident_list'                             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_ident_list ("ident_list", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_ident_list::
internalAppendValues (const GGS_lstring & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ident_list::
internalPrependValues (const GGS_lstring & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ident_list::
addAssign_operation (const GGS_lstring & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_ident_list GGS_ident_list::
operator_concat (const GGS_ident_list & inOperand) const {
  GGS_ident_list result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ident_list::
dotAssign_operation (const GGS_ident_list inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_ident_list * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->obj_name ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ident_list::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ident_list::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->obj_name
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ident_list  GGS_ident_list::
constructor_emptyList (void) {
  GGS_ident_list result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ident_list  GGS_ident_list::
constructor_listWithValue (const GGS_lstring & argument_0) {
  GGS_ident_list result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ident_list::
internalSubListWithRange (GGS_ident_list & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->obj_name) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ident_list GGS_ident_list::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_ident_list result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ident_list GGS_ident_list::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_ident_list result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ident_list::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@ident_list", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_ident_list::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->obj_name ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ident_list::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->obj_name ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ident_list::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->obj_name ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ident_list::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->obj_name ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_ident_list::
reader_obj_nameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->obj_name ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ident_list::
modifier_setObj_nameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->obj_name = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_ident_list::cEnumerator::_obj_name (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->obj_name ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_ident_list::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_ident_list * p = NULL ;
    macroMyNew (p, GGS_ident_list (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ident_list GGS_ident_list::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_ident_list result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_ident_list * p = dynamic_cast <const GGS_ident_list *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_ident_list, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_ident_list::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_ident_list ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_ident_list_map'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_ident_list_map::e_ident_list_map (void) :
objs () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@ident_list_map'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_ident_list_map ("ident_list_map", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_ident_list_map::
elementOf_GGS_ident_list_map (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_ident_list_map & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ident_list_map::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.objs.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_ident_list_map::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_ident_list_map * ptr = dynamic_cast <const elementOf_GGS_ident_list_map *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.objs.operator_isEqual (ptr->mInfo.objs)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_ident_list_map::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_ident_list_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_ident_list_map * info = (e_ident_list_map *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_ident_list_map::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_ident_list_map *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_ident_list_map * info = (e_ident_list_map *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_ident_list_map GGS_ident_list_map::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ident_list_map result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ident_list_map::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_ident_list_map info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ident_list_map::
operator_isEqual (const GGS_ident_list_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ident_list_map::
operator_isNotEqual (const GGS_ident_list_map & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_ident_list_map::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_ident_list_map::
removeElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_ident_list & outParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  AC_galgas_map_element * removedElement = NULL ;
  PMSInt32 elementID = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    removedElement = internalRemove (inKey) ;
    if (removedElement == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
      outParameter0.drop () ;
    }else{
      cElement * ptr = (cElement *) removedElement ;
      elementID = ptr->mID ;
      outParameter0 = ptr->mInfo.objs ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
  macroMyDelete (removedElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ident_list_map::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_ident_list & inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_ident_list_map info  ;
    info.objs = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ident_list_map::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_ident_list   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.objs ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_ident_list_map::kSearchMessage_get [] = {
  TO_UNICODE ('K'),
  TO_UNICODE ('e'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_ident_list_map::
method_get (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_ident_list   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_get,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_ident_list_map::kRemoveMessage_delete [] = {
  TO_UNICODE ('K'),
  TO_UNICODE ('e'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_ident_list_map::
modifier_delete (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_ident_list & outParameter0 COMMA_LOCATION_ARGS) {
  removeElement (inLexique,
                  kRemoveMessage_delete,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_ident_list_map::kInsertMessage_add [] = {
  TO_UNICODE ('K'),
  TO_UNICODE ('e'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('u'),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_ident_list_map::
modifier_add (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_ident_list & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_add,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_ident_list_map GGS_ident_list_map::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_ident_list_map & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ident_list_map result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ident_list_map GGS_ident_list_map::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ident_list_map result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ident_list_map::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @ident_list_map " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_ident_list  & GGS_ident_list_map::cEnumerator::_objs (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.objs ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_ident_list_map::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_ident_list_map * p = NULL ;
    macroMyNew (p, GGS_ident_list_map (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ident_list_map GGS_ident_list_map::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_ident_list_map result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_ident_list_map * p = dynamic_cast <const GGS_ident_list_map *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_ident_list_map, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_ident_list_map::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_ident_list_map ;
}

//---------------------------------------------------------------------------*

GGS_ident_list_map GGS_ident_list_map::constructor_mapWithKeyAndValue (C_Compiler & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_ident_list & inValue0
                                             COMMA_LOCATION_ARGS) {
  GGS_ident_list_map result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'cPtr_oil_obj'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_oil_obj::
cPtr_oil_obj (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
desc (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_oil_obj * GGS_oil_obj::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_oil_obj) ;
    return (cPtr_oil_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_oil_obj::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@oil_obj:"
           << desc.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_oil_obj::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_oil_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_oil_obj (& typeid (cPtr_oil_obj), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_oil_obj::galgasRTTI (void) const {
  return & gClassInfoFor__oil_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        GALGAS class 'GGS_oil_obj'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_oil_obj ("oil_obj", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_oil_obj::
GGS_oil_obj (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_oil_obj::
GGS_oil_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_oil_obj GGS_oil_obj::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_oil_obj result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_oil_obj *> (inPointer) != NULL)
      : (typeid (cPtr_oil_obj) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_oil_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_oil_obj),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_oil_obj::
reader_desc (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_oil_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_oil_obj *) mPointer)->desc ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_oil_obj::actualTypeName (void) const {
  return "oil_obj" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_oil_obj::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__oil_obj ("oil_obj", & kTypeDescriptor_GGS_oil_obj) ;

//---------------------------------------------------------------------------*

GGS_object GGS_oil_obj::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_oil_obj * p = NULL ;
    macroMyNew (p, GGS_oil_obj (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_oil_obj GGS_oil_obj::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_oil_obj result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_oil_obj * p = dynamic_cast <const GGS_oil_obj *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_oil_obj, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_oil_obj::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_oil_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_autostart_obj'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_autostart_obj::
cPtr_autostart_obj (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
location (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_autostart_obj * GGS_autostart_obj::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_autostart_obj) ;
    return (cPtr_autostart_obj *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_autostart_obj::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@autostart_obj:"
           << location.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_autostart_obj::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_autostart_obj::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_autostart_obj (& typeid (cPtr_autostart_obj), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_autostart_obj::galgasRTTI (void) const {
  return & gClassInfoFor__autostart_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_autostart_obj'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_autostart_obj ("autostart_obj", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_autostart_obj::
GGS_autostart_obj (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_autostart_obj::
GGS_autostart_obj (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_autostart_obj GGS_autostart_obj::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_autostart_obj result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_autostart_obj *> (inPointer) != NULL)
      : (typeid (cPtr_autostart_obj) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_autostart_obj (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_autostart_obj),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_autostart_obj::
reader_location (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_autostart_obj *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_autostart_obj *) mPointer)->location ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_autostart_obj::actualTypeName (void) const {
  return "autostart_obj" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_autostart_obj::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__autostart_obj ("autostart_obj", & kTypeDescriptor_GGS_autostart_obj) ;

//---------------------------------------------------------------------------*

GGS_object GGS_autostart_obj::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_autostart_obj * p = NULL ;
    macroMyNew (p, GGS_autostart_obj (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_autostart_obj GGS_autostart_obj::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_autostart_obj result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_autostart_obj * p = dynamic_cast <const GGS_autostart_obj *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_autostart_obj, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_autostart_obj::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_autostart_obj ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_autostart_void'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_autostart_void::
cPtr_autostart_void (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_autostart_obj (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_autostart_void * GGS_autostart_void::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_autostart_void) ;
    return (cPtr_autostart_void *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_autostart_void::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_autostart_void * ptr = dynamic_cast <const cPtr_autostart_void *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_autostart_void::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@autostart_void:"
           << location.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_autostart_void::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_autostart_void::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_autostart_void (& typeid (cPtr_autostart_void), & typeid (cPtr_autostart_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_autostart_void::galgasRTTI (void) const {
  return & gClassInfoFor__autostart_void ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_autostart_void::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_autostart_void (location COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_autostart_void'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_autostart_void ("autostart_void", true, & kTypeDescriptor_GGS_autostart_obj) ;

//---------------------------------------------------------------------------*

GGS_autostart_void::
GGS_autostart_void (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_autostart_void::
GGS_autostart_void (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_autostart_void GGS_autostart_void::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_autostart_void result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_autostart_void *> (inPointer) != NULL)
      : (typeid (cPtr_autostart_void) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_autostart_void (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_autostart_void),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_autostart_void GGS_autostart_void::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_autostart_void result ;
  macroMyNew (result.mPointer, cPtr_autostart_void (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_autostart_void::actualTypeName (void) const {
  return "autostart_void" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__autostart_void ("autostart_void", gClassInfoFor__autostart_obj, & kTypeDescriptor_GGS_autostart_void) ;

//---------------------------------------------------------------------------*

GGS_object GGS_autostart_void::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_autostart_void * p = NULL ;
    macroMyNew (p, GGS_autostart_void (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_autostart_void GGS_autostart_void::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_autostart_void result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_autostart_void * p = dynamic_cast <const GGS_autostart_void *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_autostart_void, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_autostart_void::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_autostart_void ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_autostart_false'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_autostart_false::
cPtr_autostart_false (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_autostart_obj (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_autostart_false * GGS_autostart_false::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_autostart_false) ;
    return (cPtr_autostart_false *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_autostart_false::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_autostart_false * ptr = dynamic_cast <const cPtr_autostart_false *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = location.operator_isEqual (ptr->location).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_autostart_false::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@autostart_false:"
           << location.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_autostart_false::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_autostart_false::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_autostart_false (& typeid (cPtr_autostart_false), & typeid (cPtr_autostart_obj), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_autostart_false::galgasRTTI (void) const {
  return & gClassInfoFor__autostart_false ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_autostart_false::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_autostart_false (location COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_autostart_false'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_autostart_false ("autostart_false", true, & kTypeDescriptor_GGS_autostart_obj) ;

//---------------------------------------------------------------------------*

GGS_autostart_false::
GGS_autostart_false (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_autostart_false::
GGS_autostart_false (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_autostart_false GGS_autostart_false::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_autostart_false result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_autostart_false *> (inPointer) != NULL)
      : (typeid (cPtr_autostart_false) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_autostart_false (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_autostart_false),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_autostart_false GGS_autostart_false::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_autostart_false result ;
  macroMyNew (result.mPointer, cPtr_autostart_false (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_autostart_false::actualTypeName (void) const {
  return "autostart_false" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__autostart_false ("autostart_false", gClassInfoFor__autostart_obj, & kTypeDescriptor_GGS_autostart_false) ;

//---------------------------------------------------------------------------*

GGS_object GGS_autostart_false::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_autostart_false * p = NULL ;
    macroMyNew (p, GGS_autostart_false (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_autostart_false GGS_autostart_false::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_autostart_false result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_autostart_false * p = dynamic_cast <const GGS_autostart_false *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_autostart_false, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_autostart_false::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_autostart_false ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Implementation of function "empty_lstring"                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lstring  function_empty_lstring (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_empty_lstring at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_lstring  var_cas_ls ;
  var_cas_ls = GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (287)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_empty_lstring\n") ;
  #endif
  return var_cas_ls ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_empty_lstring (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_lstring  result = function_empty_lstring (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_empty_lstring ("empty_lstring",
                              functionForGenericCall_empty_lstring,
                              & kTypeDescriptor_GGS_lstring ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  Implementation of function "void_obj"                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_basic_type  function_void_obj (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_void_obj at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_basic_type  var_cas_v ;
  var_cas_v = GGS_void ::constructor_new (inLexique, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (293)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_void_obj\n") ;
  #endif
  return var_cas_v ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_void_obj (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_basic_type  result = function_void_obj (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_void_obj ("void_obj",
                              functionForGenericCall_void_obj,
                              & kTypeDescriptor_GGS_basic_type ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  Implementation of routine "set_uint32"                   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_set_uint32 (C_Compiler & inLexique,
                                GGS_basic_type  & var_cas_t,
                                GGS_luint64   var_cas_i,
                                GGS_string  var_cas_att
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_set_uint32 at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  { const GGS_basic_type _var_7484 = var_cas_t ; // CAST instruction
    if (_var_7484.getPtr () != NULL) {
      macroValidPointer (_var_7484.getPtr ()) ;
      if (typeid (cPtr_void) == typeid (* (_var_7484.getPtr ()))) {
        var_cas_t = GGS_uint32_class ::constructor_new (inLexique, var_cas_i.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (313)), var_cas_i.reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (313)).reader_uint (inLexique COMMA_SOURCE_FILE_AT_LINE (313)) COMMA_SOURCE_FILE_AT_LINE (313)) ;
      }else{
        var_cas_i.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (var_cas_att).operator_concat (GGS_string (" Redefinition")) COMMA_SOURCE_FILE_AT_LINE (316)) ;
        var_cas_t.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (316)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("was defined here") COMMA_SOURCE_FILE_AT_LINE (317)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_set_uint32\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Implementation of routine "set_uint64"                   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_set_uint64 (C_Compiler & inLexique,
                                GGS_basic_type  & var_cas_t,
                                GGS_luint64   var_cas_i,
                                GGS_string  var_cas_att
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_set_uint64 at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  { const GGS_basic_type _var_8083 = var_cas_t ; // CAST instruction
    if (_var_8083.getPtr () != NULL) {
      macroValidPointer (_var_8083.getPtr ()) ;
      if (typeid (cPtr_void) == typeid (* (_var_8083.getPtr ()))) {
        var_cas_t = GGS_uint64_class ::constructor_new (inLexique, var_cas_i.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (337)), var_cas_i.reader_uint64 (inLexique COMMA_SOURCE_FILE_AT_LINE (337)) COMMA_SOURCE_FILE_AT_LINE (337)) ;
      }else{
        var_cas_i.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (var_cas_att).operator_concat (GGS_string (" Redefinition")) COMMA_SOURCE_FILE_AT_LINE (340)) ;
        var_cas_t.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (340)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("was defined here") COMMA_SOURCE_FILE_AT_LINE (341)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_set_uint64\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Implementation of routine "set_lstring"                   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_set_lstring (C_Compiler & inLexique,
                                GGS_basic_type  & var_cas_t,
                                GGS_lstring   var_cas_s,
                                GGS_string  var_cas_att
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_set_lstring at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  { const GGS_basic_type _var_8689 = var_cas_t ; // CAST instruction
    if (_var_8689.getPtr () != NULL) {
      macroValidPointer (_var_8689.getPtr ()) ;
      if (typeid (cPtr_void) == typeid (* (_var_8689.getPtr ()))) {
        var_cas_t = GGS_string_class ::constructor_new (inLexique, var_cas_s.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (361)), var_cas_s.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (361)) COMMA_SOURCE_FILE_AT_LINE (361)) ;
      }else{
        var_cas_s.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (var_cas_att).operator_concat (GGS_string (" Redefinition")) COMMA_SOURCE_FILE_AT_LINE (364)) ;
        var_cas_t.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (364)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("was defined here") COMMA_SOURCE_FILE_AT_LINE (365)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_set_lstring\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Implementation of routine "set_bool"                    *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_set_bool (C_Compiler & inLexique,
                                GGS_basic_type  & var_cas_t,
                                GGS_lbool   var_cas_b,
                                GGS_string  var_cas_att
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_set_bool at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  { const GGS_basic_type _var_9280 = var_cas_t ; // CAST instruction
    if (_var_9280.getPtr () != NULL) {
      macroValidPointer (_var_9280.getPtr ()) ;
      if (typeid (cPtr_bool_class) == typeid (* (_var_9280.getPtr ()))) {
        var_cas_b.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (GGS_string ("Redefinition of ")).operator_concat (var_cas_att) COMMA_SOURCE_FILE_AT_LINE (386)) ;
        var_cas_t.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (386)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("was defined here") COMMA_SOURCE_FILE_AT_LINE (387)) ;
      }else{
        var_cas_t = GGS_bool_class ::constructor_new (inLexique, var_cas_b.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (388)), var_cas_b.reader_bool (inLexique COMMA_SOURCE_FILE_AT_LINE (388)) COMMA_SOURCE_FILE_AT_LINE (388)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_set_bool\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Implementation of function "getBool"                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_bool function_getBool (C_Compiler & inLexique,
                                const GGS_basic_type   var_cas_t,
                                const GGS_bool  var_cas_def COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_getBool at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_bool var_cas_b ;
  { const GGS_basic_type _var_9466 = var_cas_t ; // CAST instruction
    if (_var_9466.getPtr () != NULL) {
      macroValidPointer (_var_9466.getPtr ()) ;
      if (typeid (cPtr_bool_class) == typeid (* (_var_9466.getPtr ()))) {
        const GGS_bool_class var_cas_bc (_var_9466.getPtr ()) ;
        var_cas_b = var_cas_bc.reader_value (inLexique COMMA_SOURCE_FILE_AT_LINE (399)) ;
      }else{
        var_cas_b = var_cas_def ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_getBool\n") ;
  #endif
  return var_cas_b ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_getBool (C_Compiler & inLexique,
                           const GGS_objectlist & inEffectiveParameterArray,
                           const GGS_location & inErrorLocation
                           COMMA_LOCATION_ARGS) {
  const GGS_basic_type  arg_0 = GGS_basic_type ::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (0) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_bool arg_1 = GGS_bool::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (1) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_bool result = function_getBool (inLexique,
                            arg_0,
                            arg_1
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

static const C_galgas_type_descriptorEX *
kArgumentTypeList_getBool [2] = {& kTypeDescriptor_GGS_basic_type ,
                              & kTypeDescriptor_GGS_bool} ;

const C_galgas_function_descriptorEX
kFunction_descriptor_getBool ("getBool",
                              functionForGenericCall_getBool,
                              & kTypeDescriptor_GGS_bool,
                              2,
                              kArgumentTypeList_getBool) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   Implementation of function "yes_no"                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string function_yes_no (C_Compiler &,
                                GGS_bool  var_cas_b COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_yes_no at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_res ;
  const GGS_bool cond_9561 = var_cas_b ;
  if (cond_9561.isBuiltAndTrue ()) {
    var_cas_res = GGS_string ("YES") ;
  }else if (cond_9561.isBuiltAndFalse ()) {
    var_cas_res = GGS_string ("NO") ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_yes_no\n") ;
  #endif
  return var_cas_res ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_yes_no (C_Compiler & inLexique,
                           const GGS_objectlist & inEffectiveParameterArray,
                           const GGS_location & inErrorLocation
                           COMMA_LOCATION_ARGS) {
  const GGS_bool arg_0 = GGS_bool::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (0) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_string result = function_yes_no (inLexique,
                            arg_0
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

static const C_galgas_type_descriptorEX *
kArgumentTypeList_yes_no [1] = {& kTypeDescriptor_GGS_bool} ;

const C_galgas_function_descriptorEX
kFunction_descriptor_yes_no ("yes_no",
                              functionForGenericCall_yes_no,
                              & kTypeDescriptor_GGS_string,
                              1,
                              kArgumentTypeList_yes_no) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 Implementation of function "true_false"                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string function_true_false (C_Compiler &,
                                GGS_bool  var_cas_b COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_true_false at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_res ;
  const GGS_bool cond_9675 = var_cas_b ;
  if (cond_9675.isBuiltAndTrue ()) {
    var_cas_res = GGS_string ("true") ;
  }else if (cond_9675.isBuiltAndFalse ()) {
    var_cas_res = GGS_string ("false") ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_true_false\n") ;
  #endif
  return var_cas_res ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_true_false (C_Compiler & inLexique,
                           const GGS_objectlist & inEffectiveParameterArray,
                           const GGS_location & inErrorLocation
                           COMMA_LOCATION_ARGS) {
  const GGS_bool arg_0 = GGS_bool::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (0) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_string result = function_true_false (inLexique,
                            arg_0
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

static const C_galgas_type_descriptorEX *
kArgumentTypeList_true_false [1] = {& kTypeDescriptor_GGS_bool} ;

const C_galgas_function_descriptorEX
kFunction_descriptor_true_false ("true_false",
                              functionForGenericCall_true_false,
                              & kTypeDescriptor_GGS_string,
                              1,
                              kArgumentTypeList_true_false) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 Implementation of function "bool_define"                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string function_bool_define (C_Compiler & inLexique,
                                GGS_string  var_cas_flag,
                                GGS_bool  var_cas_b COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_bool_define at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_res ;
  var_cas_res = ((((GGS_string ("#define    ")).operator_concat (var_cas_flag)).operator_concat (GGS_string ("    "))).operator_concat (function_yes_no (inLexique, var_cas_b COMMA_SOURCE_FILE_AT_LINE (418)))).operator_concat (GGS_string ("\n")) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_bool_define\n") ;
  #endif
  return var_cas_res ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_bool_define (C_Compiler & inLexique,
                           const GGS_objectlist & inEffectiveParameterArray,
                           const GGS_location & inErrorLocation
                           COMMA_LOCATION_ARGS) {
  const GGS_string arg_0 = GGS_string::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (0) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_bool arg_1 = GGS_bool::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (1) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_string result = function_bool_define (inLexique,
                            arg_0,
                            arg_1
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

static const C_galgas_type_descriptorEX *
kArgumentTypeList_bool_define [2] = {& kTypeDescriptor_GGS_string,
                              & kTypeDescriptor_GGS_bool} ;

const C_galgas_function_descriptorEX
kFunction_descriptor_bool_define ("bool_define",
                              functionForGenericCall_bool_define,
                              & kTypeDescriptor_GGS_string,
                              2,
                              kArgumentTypeList_bool_define) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of function "bool_make_define"                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string function_bool_make_define (C_Compiler & inLexique,
                                GGS_string  var_cas_flag,
                                GGS_bool  var_cas_b COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_bool_make_define at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_res ;
  var_cas_res = (((var_cas_flag).operator_concat (GGS_string (" = "))).operator_concat (function_true_false (inLexique, var_cas_b COMMA_SOURCE_FILE_AT_LINE (426)))).operator_concat (GGS_string ("\n")) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_bool_make_define\n") ;
  #endif
  return var_cas_res ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_bool_make_define (C_Compiler & inLexique,
                           const GGS_objectlist & inEffectiveParameterArray,
                           const GGS_location & inErrorLocation
                           COMMA_LOCATION_ARGS) {
  const GGS_string arg_0 = GGS_string::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (0) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_bool arg_1 = GGS_bool::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (1) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_string result = function_bool_make_define (inLexique,
                            arg_0,
                            arg_1
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

static const C_galgas_type_descriptorEX *
kArgumentTypeList_bool_make_define [2] = {& kTypeDescriptor_GGS_string,
                              & kTypeDescriptor_GGS_bool} ;

const C_galgas_function_descriptorEX
kFunction_descriptor_bool_make_define ("bool_make_define",
                              functionForGenericCall_bool_make_define,
                              & kTypeDescriptor_GGS_string,
                              2,
                              kArgumentTypeList_bool_make_define) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of function "bool_class_define"               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string function_bool_class_define (C_Compiler & inLexique,
                                GGS_string  var_cas_flag,
                                GGS_basic_type   var_cas_t,
                                GGS_bool  var_cas_def COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_bool_class_define at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_res ;
  { const GGS_basic_type _var_10236 = var_cas_t ; // CAST instruction
    if (_var_10236.getPtr () != NULL) {
      macroValidPointer (_var_10236.getPtr ()) ;
      if (typeid (cPtr_bool_class) == typeid (* (_var_10236.getPtr ()))) {
        const GGS_bool_class var_cas_b (_var_10236.getPtr ()) ;
        var_cas_res = function_bool_define (inLexique, var_cas_flag, var_cas_b.reader_value (inLexique COMMA_SOURCE_FILE_AT_LINE (437)) COMMA_SOURCE_FILE_AT_LINE (437)) ;
      }else{
        var_cas_res = function_bool_define (inLexique, var_cas_flag, var_cas_def COMMA_SOURCE_FILE_AT_LINE (439)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_bool_class_define\n") ;
  #endif
  return var_cas_res ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_bool_class_define (C_Compiler & inLexique,
                           const GGS_objectlist & inEffectiveParameterArray,
                           const GGS_location & inErrorLocation
                           COMMA_LOCATION_ARGS) {
  const GGS_string arg_0 = GGS_string::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (0) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_basic_type  arg_1 = GGS_basic_type ::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (1) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_bool arg_2 = GGS_bool::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (2) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_string result = function_bool_class_define (inLexique,
                            arg_0,
                            arg_1,
                            arg_2
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

static const C_galgas_type_descriptorEX *
kArgumentTypeList_bool_class_define [3] = {& kTypeDescriptor_GGS_string,
                              & kTypeDescriptor_GGS_basic_type ,
                              & kTypeDescriptor_GGS_bool} ;

const C_galgas_function_descriptorEX
kFunction_descriptor_bool_class_define ("bool_class_define",
                              functionForGenericCall_bool_class_define,
                              & kTypeDescriptor_GGS_string,
                              3,
                              kArgumentTypeList_bool_class_define) ;

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of function "bool_class_make_define"             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string function_bool_class_make_define (C_Compiler & inLexique,
                                GGS_string  var_cas_flag,
                                GGS_basic_type   var_cas_t,
                                GGS_bool  var_cas_def COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_bool_class_make_define at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_res ;
  { const GGS_basic_type _var_10506 = var_cas_t ; // CAST instruction
    if (_var_10506.getPtr () != NULL) {
      macroValidPointer (_var_10506.getPtr ()) ;
      if (typeid (cPtr_bool_class) == typeid (* (_var_10506.getPtr ()))) {
        const GGS_bool_class var_cas_b (_var_10506.getPtr ()) ;
        var_cas_res = function_bool_make_define (inLexique, var_cas_flag, var_cas_b.reader_value (inLexique COMMA_SOURCE_FILE_AT_LINE (451)) COMMA_SOURCE_FILE_AT_LINE (451)) ;
      }else{
        var_cas_res = function_bool_make_define (inLexique, var_cas_flag, var_cas_def COMMA_SOURCE_FILE_AT_LINE (453)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_bool_class_make_define\n") ;
  #endif
  return var_cas_res ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_bool_class_make_define (C_Compiler & inLexique,
                           const GGS_objectlist & inEffectiveParameterArray,
                           const GGS_location & inErrorLocation
                           COMMA_LOCATION_ARGS) {
  const GGS_string arg_0 = GGS_string::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (0) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_basic_type  arg_1 = GGS_basic_type ::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (1) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_bool arg_2 = GGS_bool::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (2) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_string result = function_bool_class_make_define (inLexique,
                            arg_0,
                            arg_1,
                            arg_2
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

static const C_galgas_type_descriptorEX *
kArgumentTypeList_bool_class_make_define [3] = {& kTypeDescriptor_GGS_string,
                              & kTypeDescriptor_GGS_basic_type ,
                              & kTypeDescriptor_GGS_bool} ;

const C_galgas_function_descriptorEX
kFunction_descriptor_bool_class_make_define ("bool_class_make_define",
                              functionForGenericCall_bool_class_make_define,
                              & kTypeDescriptor_GGS_string,
                              3,
                              kArgumentTypeList_bool_class_make_define) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  Implementation of routine "bool_flag"                    *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_bool_flag (C_Compiler & inLexique,
                                GGS_string & var_cas_res,
                                GGS_basic_type   var_cas_b,
                                GGS_string  var_cas_flag
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_bool_flag at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  { const GGS_basic_type _var_10909 = var_cas_b ; // CAST instruction
    if (_var_10909.getPtr () != NULL) {
      macroValidPointer (_var_10909.getPtr ()) ;
      if (typeid (cPtr_void) == typeid (* (_var_10909.getPtr ()))) {
      }else if (typeid (cPtr_bool_class) == typeid (* (_var_10909.getPtr ()))) {
        const GGS_bool_class var_cas_bo (_var_10909.getPtr ()) ;
        const GGS_bool cond_10779 = var_cas_bo.reader_value (inLexique COMMA_SOURCE_FILE_AT_LINE (466)) ;
        if (cond_10779.isBuiltAndTrue ()) {
          var_cas_res.appendCString ("#define ") ;
          var_cas_res.dotAssign_operation (var_cas_flag) ;
          var_cas_res.appendCString ("\n") ;
        }
      }else{
        var_cas_b.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (472)).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("Internal error, wrong datatype") COMMA_SOURCE_FILE_AT_LINE (473)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_bool_flag\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Implementation of routine "p_bt"                      *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_p_bt (C_Compiler & inLexique,
                                const GGS_basic_type   var_cas_bt
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_p_bt at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_string var_cas_res ;
  if (var_cas_bt.isBuilt ()) {
    var_cas_bt (HERE)->method_string (inLexique, var_cas_res COMMA_SOURCE_FILE_AT_LINE (480)) ;
  }
  inLexique.printMessage ((((var_cas_bt.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (481)).reader_locationString (inLexique COMMA_SOURCE_FILE_AT_LINE (481))).operator_concat (GGS_string (": "))).operator_concat (var_cas_res)).operator_concat (GGS_string ("\n")) COMMA_SOURCE_FILE_AT_LINE (481)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_p_bt\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Implementation of function "luint64_value"                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_luint64  function_luint64_value (C_Compiler & inLexique,
                                const GGS_uint64_class   var_cas_c COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_luint64_value at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_luint64  var_cas_v ;
  var_cas_v = GGS_luint64 ::constructor_new (inLexique, var_cas_c.reader_value (inLexique COMMA_SOURCE_FILE_AT_LINE (488)), var_cas_c.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (488)) COMMA_SOURCE_FILE_AT_LINE (488)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_luint64_value\n") ;
  #endif
  return var_cas_v ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_luint64_value (C_Compiler & inLexique,
                           const GGS_objectlist & inEffectiveParameterArray,
                           const GGS_location & inErrorLocation
                           COMMA_LOCATION_ARGS) {
  const GGS_uint64_class  arg_0 = GGS_uint64_class ::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (0) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_luint64  result = function_luint64_value (inLexique,
                            arg_0
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

static const C_galgas_type_descriptorEX *
kArgumentTypeList_luint64_value [1] = {& kTypeDescriptor_GGS_uint64_class } ;

const C_galgas_function_descriptorEX
kFunction_descriptor_luint64_value ("luint64_value",
                              functionForGenericCall_luint64_value,
                              & kTypeDescriptor_GGS_luint64 ,
                              1,
                              kArgumentTypeList_luint64_value) ;

//---------------------------------------------------------------------------*

