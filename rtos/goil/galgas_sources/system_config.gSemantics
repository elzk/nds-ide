#
# @file system_config.ggs
#
# @section File description
#
# This file contains data types used for the configuration of
# the whole system (application, com, os, ...). These data
# structure are filled to prepare code generation using
# the template interpreter
#
# @section Copyright
#
# Trampoline OS
#
# Trampoline is copyright (c) IRCCyN 2005+
# Trampoline is protected by the french intellectual property law.
#
# goil is distributed under the GNU Public Licence V2
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation.
#
# This program is distributed in the hope it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
# more details.
#
# @section File informations
#
# $Date$
# $Rev$
# $Author$
# $URL$
#

semantics system_config:

import semantics goil_types_root in "goil_types_root.gSemantics";
import semantics template_invocation in "template_invocation.gSemantics";
import semantics goil_env_verification in "goil_env_verification.gSemantics";
import option goil_options in "goil_options.gOption";


import "goil_types_root.gSemantics";
import "template_invocation.gSemantics";
import "goil_env_verification.gSemantics";
import "goil_options.gOption";


#class @systemConfig {
#  @string  version      feature setter;
#  @lstring compilerKind feature setter;
#  @goilTemplateFieldMapList tasks feature setter;
#}
#
#routine setCompilerKind ??@root_obj cpu ?!@systemConfig cfg:
#  cast [[cpu os] memmap]:
#  when == @memmap_true mm do [!?cfg setCompilerKind ![mm compiler]];
#  else end cast;
#end routine;
#
#function emptySystemConfig ->@systemConfig cfg:
#  cfg := [@systemConfig new
#    !"1.0"
#    !empty_lstring[]
#    ![@goilTemplateFieldMapList emptyList]
#  ];
#end function;
#
enum @taskKind {
  all, basic, extended
}{}  

routine setAppRelatedAttributes
  ?!@goilTemplateFieldMap fieldMap
  ??@root_obj cpu
  ??@stringMap appForObj
  ??@lstring objName
:
  if [option goil_options.autosar_on value] then
    if [appForObj count] > 0 then
      @bool trustedApp := false;
      @string appName;
      [appForObj get !objName ?appName];
      addStringFieldValue !?fieldMap ![@lstring new !"APPLICATION" !here] !appName;
      # look if the OS Application is trusted
      @app_obj app;
#      @app_map apps := [cpu applis];
#      log apps;
      [[cpu applis] get ![@lstring new !appName !here] ?app];
      cast [app trusted] :
      when == @app_trusted_true do trustedApp := true;
      else end cast;
      addBoolFieldValue !?fieldMap ![@lstring new !"TRUSTED" !here] !trustedApp;
    end if;
  end if;
end routine;
  
#
# compute an ordered task list (ie extended tasks first, then basic task
#
function orderedTaskList
  ??@root_obj cpu
  ->@tasks_by_type taskList
:
  taskList := [@tasks_by_type emptySortedList];
  # sort tasks according to type (basic or extended)
  foreach [cpu tasks] do
    if [[task events] length] > 0 then
      taskList += !0 ![lkey string];
    else
      taskList += !1 ![lkey string];
    end if;
  end foreach;
end function;

#
# compute a task list usable for templates
#
routine computeTaskList
  ??@root_obj cpu
  ??@prio_map actualPriorities
  ??@stringMap appForObj
  ??@taskKind kind 
  ?!@goilTemplateFieldMapList taskList
:
  @tasks_by_type sTasks := orderedTaskList[!cpu];

  foreach sTasks do
    if (kind == [@taskKind all]) |
       ((type == 0) & (kind == [@taskKind extended])) |
       ((type == 1) & (kind == [@taskKind basic])) then
      @task_obj task;
      @lstring taskName := [@lstring new !name !here];
      [[cpu tasks] get !taskName ?task];
      @goilTemplateFieldMap fieldMap [emptyMap];
      addStringFieldValue !?fieldMap ![@lstring new !"NAME" ![[cpu tasks] locationForKey !name]] !name;
      addStringFieldValue !?fieldMap ![@lstring new !"PROCESSKIND" !here] !"Task";
      addBoolFieldValue !?fieldMap ![@lstring new !"EXTENDEDTASK" !here] !(type == 0);
      addBoolFieldValue !?fieldMap ![@lstring new !"NONPREEMPTABLE" !here] ![[task schedule] string] == "NON";
      @uint actualPrio;
      @uint activation;
      [actualPriorities get !taskName ?actualPrio ?activation];
      addUnsignedFieldValue !?fieldMap ![@lstring new !"PRIORITY" !here] ![actualPrio uint64];
      addUnsignedFieldValue !?fieldMap ![@lstring new !"ACTIVATION" !here] ![activation uint64];
    
      cast [task autostart]:
      when == @task_autostart_true do 
        addBoolFieldValue !?fieldMap ![@lstring new !"AUTOSTART" !here] !true;
      when == @task_autostart_false do
        addBoolFieldValue !?fieldMap ![@lstring new !"AUTOSTART" !here] !false;
      else
        error [[task autostart] location]: "internal error, AUTOSTART type is undefined";
      end cast;
      if [[task schedule] string] == "FULL" then
        @bool internalFound := false;
        foreach [task resources] (@lstring resourceName) do
          if not internalFound then
            @resource_obj resource;
            [[cpu resources] get !resourceName ?resource];
            cast [resource property]:
            when == @resource_property_internal_obj do
              internalFound := true;
              addStringFieldValue !?fieldMap ![@lstring new !"INTERNALRESOURCE" !here] ![resourceName string];
              addBoolFieldValue !?fieldMap ![@lstring new !"USEINTERNALRESOURCE" !here] !true;
            else end cast;
          end if;
        end foreach;
        if not internalFound then
          addStringFieldValue !?fieldMap ![@lstring new !"INTERNALRESOURCE" !here] !"";
          addBoolFieldValue !?fieldMap ![@lstring new !"USEINTERNALRESOURCE" !here] !false;
        end if;
      else
        addStringFieldValue !?fieldMap ![@lstring new !"INTERNALRESOURCE" !here] !"";
        addBoolFieldValue !?fieldMap ![@lstring new !"USEINTERNALRESOURCE" !here] !false;
      end if;
    
      @goilTemplateFieldMapList resourceList [emptyList];
      foreach [task resources] (@lstring resourceName) do
        @resource_obj resource;
        [[cpu resources] get !resourceName ?resource];
        cast [resource property]:
        when == @resource_property_internal_obj do
        else
          @goilTemplateFieldMap resourceFieldMap [emptyMap];
          addStringFieldValue !?resourceFieldMap ![@lstring new !"RESOURCENAME" !here] ![resourceName string];
          resourceList += !resourceFieldMap;
        end cast;
      end foreach;
      addListFieldValue !?fieldMap ![@lstring new !"RESOURCES" !here] !resourceList;
    
      # Add the free fields
      foreach [task others] do
        cast value:
        when == @bool_class bool do
          addBoolFieldValue !?fieldMap !lkey ![bool value];
        when == @uint64_class number do
          addUnsignedFieldValue !?fieldMap !lkey ![number value];
        when == @string_class str do
          addStringFieldValue !?fieldMap !lkey ![str value];
        else end cast;
      end foreach;

      setAppRelatedAttributes !?fieldMap !cpu !appForObj !taskName;  

      taskList += !fieldMap;
    end if;
  end foreach;
end routine;

#
# compute an ISR list usable for templates
#
routine computeISRList
  ??@root_obj cpu
  ??@prio_map actualPriorities
  ??@stringMap appForObj
  ??@uint64 isrCategory
  ?!@goilTemplateFieldMapList isrList
:
  foreach [cpu isrs] do
    cast [isr category]:
    when == @uint64_class category do
      if [category value] == isrCategory then
        @goilTemplateFieldMap fieldMap [emptyMap];
        addStringFieldValue !?fieldMap ![@lstring new !"NAME" !here] ![lkey string];
        addStringFieldValue !?fieldMap ![@lstring new !"PROCESSKIND" !here] !"ISR";
        addBoolFieldValue   !?fieldMap ![@lstring new !"EXTENDEDTASK" !here] !false;
        @uint actualPrio;
        @uint activation;
        [actualPriorities get !lkey ?actualPrio ?activation];
        addUnsignedFieldValue !?fieldMap ![@lstring new !"PRIORITY" !here] ![actualPrio uint64];
        addUnsignedFieldValue !?fieldMap ![@lstring new !"ACTIVATION" !here] ![activation uint64];

        # Add the free fields
        foreach [isr other_fields] do
          cast value:
          when == @bool_class bool do
            addBoolFieldValue !?fieldMap !lkey ![bool value];
          when == @uint64_class number do
            addUnsignedFieldValue !?fieldMap !lkey ![number value];
          when == @string_class str do
            addStringFieldValue !?fieldMap !lkey ![str value];
          else end cast;
        end foreach;

        @goilTemplateFieldMapList resourceList [emptyList];
        foreach [isr resources] (@lstring resourceName) do
          @resource_obj resource;
          [[cpu resources] get !resourceName ?resource];
          cast [resource property]:
          when == @resource_property_internal_obj do
          else
            @goilTemplateFieldMap resourceFieldMap [emptyMap];
            addStringFieldValue !?resourceFieldMap ![@lstring new !"RESOURCENAME" !here] ![resourceName string];
            resourceList += !resourceFieldMap;
          end cast;
        end foreach;
        addListFieldValue !?fieldMap ![@lstring new !"RESOURCES" !here] !resourceList;

        setAppRelatedAttributes !?fieldMap !cpu !appForObj !lkey;  

        isrList += !fieldMap;
      end if;
    else end cast;
  end foreach;
end routine;

#
# Set up the tasks list for templates
#
routine setTasksList
  ??@root_obj cpu
  ??@prio_map actualPriorities
  ??@stringMap appForObj
  ?!@goilTemplateVariableMap cfg
:
  @goilTemplateFieldMapList taskList [emptyList];
  computeTaskList !cpu !actualPriorities !appForObj ![@taskKind all] !?taskList;
  addListValue !?cfg ![@lstring new !"TASKS" !here] !taskList;    
end routine;

#
# Set up the basic tasks list for templates
#
routine setBasicTasksList
  ??@root_obj cpu
  ??@prio_map actualPriorities
  ??@stringMap appForObj
  ?!@goilTemplateVariableMap cfg
:
  @goilTemplateFieldMapList taskList [emptyList];
  computeTaskList !cpu !actualPriorities !appForObj ![@taskKind basic] !?taskList;
  addListValue !?cfg ![@lstring new !"BASICTASKS" !here] !taskList;    
end routine;

#
# Set up the extended tasks list for templates
#
routine setExtendedTasksList
  ??@root_obj cpu
  ??@prio_map actualPriorities
  ??@stringMap appForObj
  ?!@goilTemplateVariableMap cfg
:
  @goilTemplateFieldMapList taskList [emptyList];
  computeTaskList !cpu !actualPriorities !appForObj ![@taskKind extended] !?taskList;
  addListValue !?cfg ![@lstring new !"EXTENDEDTASKS" !here] !taskList;    
end routine;

#
# Set up the ISR1 list for templates
#
routine setISRs1List
  ??@root_obj cpu
  ??@prio_map actualPriorities
  ??@stringMap appForObj
  ?!@goilTemplateVariableMap cfg
:
  @goilTemplateFieldMapList isrList [emptyList];
  computeISRList !cpu !actualPriorities !appForObj !1L !?isrList;
  addListValue !?cfg ![@lstring new !"ISRS1" !here] !isrList;    
end routine;

#
# Set up the ISR2 list for templates
#
routine setISRs2List
  ??@root_obj cpu
  ??@prio_map actualPriorities
  ??@stringMap appForObj
  ?!@goilTemplateVariableMap cfg
:
  @goilTemplateFieldMapList isrList [emptyList];
  computeISRList !cpu !actualPriorities !appForObj !2L !?isrList;
  addListValue !?cfg ![@lstring new !"ISRS2" !here] !isrList;    
end routine;

#
# Set up the processes list (extended tasks, basic tasks and ISRs 2) for templates
#
routine setProcessesList
  ??@root_obj cpu
  ??@prio_map actualPriorities
  ??@stringMap appForObj
  ?!@goilTemplateVariableMap cfg
:
  @goilTemplateFieldMapList processesList [emptyList];
  computeTaskList !cpu !actualPriorities !appForObj ![@taskKind all] !?processesList;
  computeISRList !cpu !actualPriorities !appForObj !2L !?processesList;
  addListValue !?cfg !lstringWith[!"PROCESSES"] !processesList;
end routine;

#
# set up the counters list for templates
#
routine setCountersList
  ??@root_obj cpu
  ??@stringMap appForObj
  ?!@goilTemplateVariableMap cfg
:
  @goilTemplateFieldMapList countersList [emptyList];
  @goilTemplateFieldMapList hardCountersList [emptyList];
  @goilTemplateFieldMapList softCountersList [emptyList];
  foreach [cpu counters] do
    @goilTemplateFieldMap fieldMap [emptyMap];
    addStringFieldValue !?fieldMap !lstringWith[!"NAME"] ![lkey string];
    addUnsignedFieldValue !?fieldMap !lstringWith[!"MAXALLOWEDVALUE"] !maxAllowedValue[!counter];
    addUnsignedFieldValue !?fieldMap !lstringWith[!"MINCYCLE"] !minCycle[!counter];
    addUnsignedFieldValue !?fieldMap !lstringWith[!"TICKSPERBASE"] !ticksPerBase[!counter];
    @string type := "HARDWARE_COUNTER";
    cast [counter type]:
    when == @software_counter do type := "SOFTWARE_COUNTER";
    else
      addLStringFieldValue !?fieldMap !"SOURCE" ![counter source];
    end cast;
    addStringFieldValue !?fieldMap !lstringWith[!"TYPE"] !type;

    if [lkey string] != "SystemCounter" then
      setAppRelatedAttributes !?fieldMap !cpu !appForObj !lkey;
    end if;

    countersList += !fieldMap;
    if type == "HARDWARE_COUNTER" then
      hardCountersList += !fieldMap;
    else
      softCountersList += !fieldMap;
    end if;
  end foreach;
  addListValue !?cfg !lstringWith[!"COUNTERS"] !countersList;
  addListValue !?cfg !lstringWith[!"HARDWARECOUNTERS"] !hardCountersList;
  addListValue !?cfg !lstringWith[!"SOFTWARECOUNTERS"] !softCountersList;
end routine;

#
# set up the events list for templates
#
routine setEventsList
  ??@root_obj cpu
  ??@eventMaskMap eventMasks
  ?!@goilTemplateVariableMap cfg
:
  @goilTemplateFieldMapList eventsList [emptyList];
  foreach [cpu events] do
    @goilTemplateFieldMap fieldMap [emptyMap];
    addStringFieldValue !?fieldMap ![@lstring new !"NAME" !here] ![lkey string];
    @uint64 eventMask;
    [eventMasks get !lkey ?eventMask];
    addUnsignedFieldValue !?fieldMap ![@lstring new !"MASK" ![[event mask] location]] !eventMask;
    eventsList += !fieldMap;
  end foreach;
  addListValue !?cfg ![@lstring new !"EVENTS" !here] !eventsList;
end routine;

routine setAction
  ?!@goilTemplateFieldMap fieldMap
  ??@action_obj actionobj
:
  cast actionobj:
  when == @setevent_action setEvent do
    addStringFieldValue !?fieldMap !lstringWith[!"ACTION"] !"setEvent";
    addStringFieldValue !?fieldMap !lstringWith[!"TASK"] ![[setEvent task_name] string];
    addStringFieldValue !?fieldMap !lstringWith[!"EVENT"] ![[setEvent event_name] string];
  when == @activatetask_action activateTask do
    addStringFieldValue !?fieldMap !lstringWith[!"ACTION"] !"activateTask";
    addStringFieldValue !?fieldMap !lstringWith[!"TASK"] ![[activateTask task_name] string];
  when == @callback_action callback do
    addStringFieldValue !?fieldMap !lstringWith[!"ACTION"] !"callback";
    addStringFieldValue !?fieldMap !lstringWith[!"FUNCTION"] ![[callback function_name] string];
  when == @incrementcounter_action incrementCounter do
    addStringFieldValue !?fieldMap !lstringWith[!"ACTION"] !"incrementCounter";
    addStringFieldValue !?fieldMap !lstringWith[!"TARGETCOUNTER"] ![[incrementCounter counter_name] string];
  when == @finalize_st_action finalizeScheduletable do
    addStringFieldValue !?fieldMap !lstringWith[!"ACTION"] !"finalizeScheduletable";
    addLStringFieldValue !?fieldMap !"TARGETCOUNTER" ![finalizeScheduletable scheduleTableName];
  else end cast;
end routine;

#
# set up the alarms list for templates
#
routine setAlarmsList
  ??@root_obj cpu
  ??@stringMap appForObj
  ?!@goilTemplateVariableMap cfg
:
  @goilTemplateFieldMapList alarmsList [emptyList];
  foreach [cpu alarms] do
    @goilTemplateFieldMap fieldMap [emptyMap];
    addStringFieldValue !?fieldMap !lstringWith[!"NAME"] ![lkey string];
    addStringFieldValue !?fieldMap !lstringWith[!"COUNTER"] ![[alarm counter_name] string];

    setAction !?fieldMap ![alarm action_params];

    cast [alarm autostart_params]:
    when == @alarm_autostart_true autostart do
      addBoolFieldValue !?fieldMap !lstringWith[!"AUTOSTART"] !true;
      addUnsignedFieldValue !?fieldMap !lstringWith[!"ALARMTIME"] ![[autostart alarm_time] uint64];
      addUnsignedFieldValue !?fieldMap !lstringWith[!"CYCLETIME"] ![[autostart cycle_time] uint64];
      @goilTemplateFieldMapList appmodesList [emptyList];
      foreach [autostart app_modes] (@string appMode) do
        @goilTemplateFieldMap appModeFields [emptyMap];
        addStringFieldValue !?appModeFields !lstringWith[!"APPMODE"] !appMode;
        appmodesList += !appModeFields;
      end foreach;
      addListFieldValue !?fieldMap !lstringWith[!"APPMODES"] !appmodesList;
    when == @autostart_false do
      addBoolFieldValue !?fieldMap !lstringWith[!"AUTOSTART"] !false;
    when == @autostart_void do
      addBoolFieldValue !?fieldMap !lstringWith[!"AUTOSTART"] !false;
    else end cast;
    
    setAppRelatedAttributes !?fieldMap !cpu !appForObj !lkey;
    
    alarmsList += !fieldMap;
  end foreach;
  addListValue !?cfg ![@lstring new !"ALARMS" !here] !alarmsList;
end routine;

#
# set up the resources list for templates
#
routine setResourcesList
  ??@root_obj cpu
  ??@prio_map resourcesPrio
  ??@stringMap appForObj
  ?!@goilTemplateVariableMap cfg
:
  @goilTemplateFieldMapList regularList [emptyList];
  @goilTemplateFieldMapList internalList [emptyList];
  foreach [cpu resources] do
    @goilTemplateFieldMap fieldMap [emptyMap];
    addStringFieldValue !?fieldMap ![@lstring new !"NAME" !here] ![lkey string];
    @uint priority;
    [resourcesPrio get !lkey ?priority ?*];
    addUnsignedFieldValue !?fieldMap ![@lstring new !"PRIORITY" !here] ![priority uint64];

    @goilTemplateFieldMapList taskUsage [emptyList];
    foreach [cpu tasks] prefixedBy t_ do
      if isInLstringlist[![t_task resources] !lkey] then
        @goilTemplateFieldMap usage [emptyMap];
        addStringFieldValue !?usage ![@lstring new !"NAME" !here] ![t_lkey string];
        taskUsage += !usage;
      end if;
    end foreach;
    
    addListFieldValue !?fieldMap ![@lstring new !"TASKUSAGE" !here] !taskUsage;
    
    @goilTemplateFieldMapList isrUsage [emptyList];
    foreach [cpu isrs] prefixedBy i_ do
      if isInLstringlist[![i_isr resources] !lkey] then
        @goilTemplateFieldMap usage [emptyMap];
        addStringFieldValue !?usage ![@lstring new !"NAME" !here] ![i_lkey string];
        isrUsage += !usage;
      end if;
    end foreach;

    addListFieldValue !?fieldMap ![@lstring new !"ISRUSAGE" !here] !isrUsage;
    
    setAppRelatedAttributes !?fieldMap !cpu !appForObj !lkey;  


    cast [resource property]:
    when == @resource_property_standard_obj do
      regularList += !fieldMap;
    when == @resource_property_linked_obj do
      regularList += !fieldMap;
    when == @resource_property_internal_obj do
      internalList += !fieldMap;
    else
      error [[resource property] location] : "internal error, RESOURCEPROPERTY type is undefined";
    end cast;
  end foreach;
  addListValue !?cfg ![@lstring new !"REGULARRESOURCES" !here] !regularList;
  addListValue !?cfg ![@lstring new !"INTERNALRESOURCES" !here] !internalList;
end routine;

#
# set up the messages list
#
sortedlist @receiverSortedList {
  @message_obj mess;
  @string senderName;
  @location senderLocation;
  @string receiverName;
  @location receiverLocation;
}{
  senderName >,
  receiverName >
}

sortedlist @receiverReverseSortedList {
  @message_obj mess;
  @string senderName;
  @location senderLocation;
  @string receiverName;
  @location receiverLocation;
}{
  senderName >,
  receiverName <
}

routine setFilter
  ?!@goilTemplateFieldMap fieldMap
  ??@filter_prop_obj filter
:
  cast filter:
  when == @always_filter do
    addStringFieldValue !?fieldMap ![@lstring new !"FILTER" ![filter location]] !"ALWAYS";
  when == @never_filter do
    addStringFieldValue !?fieldMap ![@lstring new !"FILTER" ![filter location]] !"NEVER";
  when == @maskednewequalsx_filter maskedNewEqualsXFilter do
    addStringFieldValue !?fieldMap ![@lstring new !"FILTER" ![filter location]] !"MASKEDNEWEQUALSX";
    addLUnsignedFieldValue !?fieldMap !"MASK" ![maskedNewEqualsXFilter mask];
    addLUnsignedFieldValue !?fieldMap !"X" ![maskedNewEqualsXFilter x];
  when == @maskednewdiffersx_filter maskedNewDiffersXFilter do
    addStringFieldValue !?fieldMap ![@lstring new !"FILTER" ![filter location]] !"MASKEDNEWDIFFERSX";
    addLUnsignedFieldValue !?fieldMap !"MASK" ![maskedNewDiffersXFilter mask];
    addLUnsignedFieldValue !?fieldMap !"X" ![maskedNewDiffersXFilter x];
  when == @newisequal_filter do
    addStringFieldValue !?fieldMap ![@lstring new !"FILTER" ![filter location]] !"NEWISEQUAL";
  when == @newisdifferent_filter do
    addStringFieldValue !?fieldMap ![@lstring new !"FILTER" ![filter location]] !"NEWISDIFFERENT";
  when == @maskednewequalsmaskedold_filter maskedNewEqualsMaskedOldFilter do
    addStringFieldValue !?fieldMap ![@lstring new !"FILTER" ![filter location]] !"MASKEDNEWEQUALSMASKEDOLD";
    addLUnsignedFieldValue !?fieldMap !"MASK" ![maskedNewEqualsMaskedOldFilter mask];
  when == @maskednewdiffersmaskedold_filter maskedNewDiffersMaskedOldFilter do
    addStringFieldValue !?fieldMap ![@lstring new !"FILTER" ![filter location]] !"MASKEDNEWDIFFERSMASKEDOLD";
    addLUnsignedFieldValue !?fieldMap !"MASK" ![maskedNewDiffersMaskedOldFilter mask];
  when == @newiswithin newIsWithinFilter do
    addStringFieldValue !?fieldMap ![@lstring new !"FILTER" ![filter location]] !"NEWISWITHIN";
    addLUnsignedFieldValue !?fieldMap !"MIN" ![newIsWithinFilter min];
    addLUnsignedFieldValue !?fieldMap !"MAX" ![newIsWithinFilter max];
  when == @newisoutside newIsOutsideFilter do
    addStringFieldValue !?fieldMap ![@lstring new !"FILTER" ![filter location]] !"NEWISOUTSIDE";
    addLUnsignedFieldValue !?fieldMap !"MIN" ![newIsOutsideFilter min];
    addLUnsignedFieldValue !?fieldMap !"MAX" ![newIsOutsideFilter max];
  when == @newisgreater_filter do
    addStringFieldValue !?fieldMap ![@lstring new !"FILTER" ![filter location]] !"NEWISGREATER";
  when == @newislessorequal_filter do
    addStringFieldValue !?fieldMap ![@lstring new !"FILTER" ![filter location]] !"NEWISLESSOREQUAL";
  when == @newisless_filter do
    addStringFieldValue !?fieldMap ![@lstring new !"FILTER" ![filter location]] !"NEWISLESS";
  when == @newisgreaterorequal_filter do
    addStringFieldValue !?fieldMap ![@lstring new !"FILTER" ![filter location]] !"NEWISGREATEROREQUAL";
  when == @oneeveryn_filter oneEveryNFilter do
    addStringFieldValue !?fieldMap ![@lstring new !"FILTER" ![filter location]] !"ONEEVERYN";
    addLUnsignedFieldValue !?fieldMap !"PERIOD" ![oneEveryNFilter period];
    addLUnsignedFieldValue !?fieldMap !"OFFSET" ![oneEveryNFilter offset];
  else end cast;
end routine;

routine setMessagesList
  ??@root_obj cpu
  ??@stringMap unused appForObj
  ?!@goilTemplateVariableMap cfg
:
  # First, a sorted list of internal receive messages is built
  # this list is sorted according to the source message/IPDU
  # It is used to build the targets of sending messages
  @receiverSortedList internalReceiversList [emptySortedList];
  foreach [cpu messages] do
    cast [mess messageproperty]:
    when == @rzi_mess_prop receiveZeroInternalMessage do
      @lstring sendMessage := [receiveZeroInternalMessage sendingmessage];
      internalReceiversList += !mess ![sendMessage string] ![sendMessage location] ![lkey string] ![lkey location];
    when == @rui_mess_prop receiveUnqueuedInternalMessage do
      @lstring sendMessage := [receiveUnqueuedInternalMessage sendingmessage];
      internalReceiversList += !mess ![sendMessage string] ![sendMessage location] ![lkey string] ![lkey location];
    when == @rqi_mess_prop receiveQueuedInternalMessage do
      @lstring sendMessage := [receiveQueuedInternalMessage sendingmessage];
      internalReceiversList += !mess ![sendMessage string] ![sendMessage location] ![lkey string] ![lkey location];
    else end cast;
  end foreach;
  
  # Second, a target map is built. The target is the first receiver
  # in the internalReceiverList.
  # At the same time a next map is built
  # the next map contains for each receiver the next receiver in the list
  # At the same time a reverse sorted list is built to be
  # able to output the messages in the correct order
  # That way a message referencing a next message is after the
  # next message in the list. This avoids to output forward declarations
  # in C
  @lstringMap internalTargets [emptyMap];
  @lstringMap nextTargets [emptyMap];
  @receiverReverseSortedList actualInternalReceiverList [emptySortedList];
  @string previousReceiver := "";
  @string previousSender := "";
  foreach internalReceiversList do
    if not [internalTargets hasKey !senderName] then
      [!?internalTargets put !lstringWith[!senderName] ![@lstring new !receiverName !receiverLocation]];
    end if;
    if senderName == previousSender then
      [!?nextTargets put !lstringWith[!previousReceiver] ![@lstring new !receiverName !receiverLocation]];
    end if;
    previousSender := senderName;
    previousReceiver := receiverName;
    actualInternalReceiverList += !mess !senderName !senderLocation !receiverName !receiverLocation;
  end foreach;

  # build the lists
  
  @goilTemplateFieldMapList messagesList [emptyList];
  @goilTemplateFieldMapList sendMessagesList [emptyList];
  @goilTemplateFieldMapList receiveMessagesList [emptyList];
  
  # internal receive messages (except the zero senders messages)
  foreach actualInternalReceiverList do
    @goilTemplateFieldMap fieldMap [emptyMap];
    addStringFieldValue !?fieldMap ![@lstring new !"NAME" !receiverLocation] !receiverName;
    # get the next target
    if [nextTargets hasKey !receiverName] then
      @lstring nextReceiveMessage;
      [nextTargets get ![@lstring new !receiverName !receiverLocation] ?nextReceiveMessage];
      addStringFieldValue !?fieldMap ![@lstring new !"NEXT" ![nextReceiveMessage location]] ![nextReceiveMessage string];
    end if;
    @mess_prop_obj messageProperty := [mess messageproperty];
    cast messageProperty:
    when == @rzi_mess_prop receiveZeroInternalMessage do
      addStringFieldValue !?fieldMap ![@lstring new !"MESSAGEPROPERTY" ![messageProperty location]] !"RECEIVE_ZERO_INTERNAL";
      addLStringFieldValue !?fieldMap !"SOURCE" ![receiveZeroInternalMessage sendingmessage];
    when == @rui_mess_prop receiveUnqueuedInternalMessage do
      @lstring senderName := [receiveUnqueuedInternalMessage sendingmessage];
      addStringFieldValue !?fieldMap ![@lstring new !"MESSAGEPROPERTY" ![messageProperty location]] !"RECEIVE_UNQUEUED_INTERNAL";
      addLStringFieldValue !?fieldMap !"SOURCE" !senderName;
      @message_obj sender;
      [[cpu messages] get !senderName ?sender];
      cast [sender messageproperty]:
      when == @ssi_mess_prop sendStaticInternalSender do
        addLStringFieldValue !?fieldMap !"CTYPE" ![sendStaticInternalSender cdatatype];
        @basic_type initialValue := [receiveUnqueuedInternalMessage initialvalue];
        @string initialValueString;
        [initialValue string ?initialValueString];
        if initialValueString != "" then
          addStringFieldValue !?fieldMap ![@lstring new !"INITIALVALUE" ![initialValue location]] !initialValueString;
        end if;
      else
        error [messageProperty location]: "MESSAGEPROPERTY of sender has an incompatible property";
        error senderName: "MESSAGEPROPERTY of sender should be SEND_STATIC_INTERNAL";
      end cast;
      setFilter !?fieldMap ![receiveUnqueuedInternalMessage filter];
    when == @rqi_mess_prop receiveQueuedInternalMessage do
      @lstring senderName := [receiveQueuedInternalMessage sendingmessage];
      addStringFieldValue !?fieldMap ![@lstring new !"MESSAGEPROPERTY" ![messageProperty location]] !"RECEIVE_QUEUED_INTERNAL";
      addLStringFieldValue !?fieldMap !"SOURCE" !senderName;
      addLUnsignedFieldValue !?fieldMap !"QUEUESIZE" ![receiveQueuedInternalMessage queuesize];
      @message_obj sender;
      [[cpu messages] get !senderName ?sender];
      cast [sender messageproperty]:
      when == @ssi_mess_prop sendStaticInternalSender do
        addLStringFieldValue !?fieldMap !"CTYPE" ![sendStaticInternalSender cdatatype];
      else
        error [messageProperty location]: "MESSAGEPROPERTY of sender has an incompatible property";
        error senderName: "MESSAGEPROPERTY of sender should be SEND_STATIC_INTERNAL";
      end cast;
      
      setFilter !?fieldMap ![receiveQueuedInternalMessage filter];
    else end cast;
    
    setAction !?fieldMap ![mess notification];
    receiveMessagesList += !fieldMap;
    messagesList += !fieldMap;
  end foreach;
  
  foreach [cpu messages] do
    @goilTemplateFieldMap fieldMap [emptyMap];
    @mess_prop_obj messageProperty := [mess messageproperty];
    @bool okMessage := true;
    @bool isSendMessage := true;
    cast messageProperty:
    when == @ssi_mess_prop sendStaticInternalMessage do
      addStringFieldValue !?fieldMap ![@lstring new !"MESSAGEPROPERTY" ![messageProperty location]] !"SEND_STATIC_INTERNAL";
      addLStringFieldValue !?fieldMap !"CTYPE" ![sendStaticInternalMessage cdatatype];
      @lstring targetMessage;
      [internalTargets get !lkey ?targetMessage];
      addLStringFieldValue !?fieldMap !"TARGET" !targetMessage;
    when == @szi_mess_prop do
      addStringFieldValue !?fieldMap ![@lstring new !"MESSAGEPROPERTY" ![messageProperty location]] !"SEND_ZERO_INTERNAL";
      @lstring targetMessage;
      [internalTargets get !lkey ?targetMessage];
      addLStringFieldValue !?fieldMap !"TARGET" !targetMessage;
#    when == @sse_mess_prop sendStaticExternalMessage do
#      addStringFieldValue !?fieldMap ![@lstring new !"MESSAGEPROPERTY" ![messageProperty location]] !"SEND_STATIC_EXTERNAL";
#      sendMessagesList += !fieldMap;
#    when == @sde_mess_prop sendDynamicExternalMessage do
#      addStringFieldValue !?fieldMap ![@lstring new !"MESSAGEPROPERTY" ![messageProperty location]] !"SEND_DYNAMIC_EXTERNAL";
#      sendMessagesList += !fieldMap;
#    when == @sze_mess_prop sendZeroExternalMessage do
#      addStringFieldValue !?fieldMap ![@lstring new !"MESSAGEPROPERTY" ![messageProperty location]] !"SEND_ZERO_EXTERNAL";
#      sendMessagesList += !fieldMap;
#    when == @rze_mess_prop receiveZeroExternalMessage do
#      addStringFieldValue !?fieldMap ![@lstring new !"MESSAGEPROPERTY" ![messageProperty location]] !"RECEIVE_ZERO_EXTERNAL";
#      receiveMessagesList += !fieldMap;
#    when == @rue_mess_prop receiveUnqueuedExternalMessage do
#      addStringFieldValue !?fieldMap ![@lstring new !"MESSAGEPROPERTY" ![messageProperty location]] !"RECEIVE_UNQUEUED_EXTERNAL";
#      receiveMessagesList += !fieldMap;
#    when == @rqe_mess_prop receiveQueuedExternalMessage do
#      addStringFieldValue !?fieldMap ![@lstring new !"MESSAGEPROPERTY" ![messageProperty location]] !"RECEIVE_QUEUED_EXTERNAL";
#      receiveMessagesList += !fieldMap;
#    when == @rde_mess_prop receiveDynamicExternalMessage do
#      addStringFieldValue !?fieldMap ![@lstring new !"MESSAGEPROPERTY" ![messageProperty location]] !"RECEIVE_DYNAMIC_EXTERNAL";
#      receiveMessagesList += !fieldMap;
    when == @rzs_mess_prop receiveZeroSendersMessage do
      addStringFieldValue !?fieldMap ![@lstring new !"MESSAGEPROPERTY" ![messageProperty location]] !"RECEIVE_ZERO_SENDERS";
      addLStringFieldValue !?fieldMap !"CTYPE" ![receiveZeroSendersMessage cdatatype];
      @basic_type initialValue := [receiveZeroSendersMessage initialvalue];
      @string initialValueString;
      [initialValue string ?initialValueString];
      if initialValueString != "" then
        addStringFieldValue !?fieldMap ![@lstring new !"INITIALVALUE" ![initialValue location]] !initialValueString;
      end if;
      isSendMessage := false;
    else
      okMessage := false;
    end cast;
    if okMessage then
      addStringFieldValue !?fieldMap !lstringWith[!"NAME"] ![lkey string];
      messagesList += !fieldMap;
      if isSendMessage then
        sendMessagesList += !fieldMap;
      else
        receiveMessagesList += !fieldMap;
      end if;
    end if;
  end foreach;
  addListValue !?cfg !lstringWith[!"MESSAGES"] !messagesList;
  addListValue !?cfg !lstringWith[!"SENDMESSAGES"] !sendMessagesList;
  addListValue !?cfg !lstringWith[!"RECEIVEMESSAGES"] !receiveMessagesList;
end routine;

#
# set up the schedule tables list
#
routine setScheduletablesList
  ??@root_obj cpu
  ??@stringMap appForObj
  ?!@goilTemplateVariableMap cfg
:
  @goilTemplateFieldMapList scheduletablesList [emptyList];
  foreach [cpu scheduletables] do
    @goilTemplateFieldMap fieldMap [emptyMap];
    addStringFieldValue !?fieldMap !lstringWith[!"NAME"] ![lkey string];
    addStringFieldValue !?fieldMap !lstringWith[!"COUNTER"] ![[scheduletable counter] string];
    
    @bool periodic := false;
    cast [scheduletable periodic]:
    when == @bool_class p do periodic := [p value];
    else end cast;
    addBoolFieldValue !?fieldMap !lstringWith[!"PERIODIC"] !periodic;
    
    @lstring syncStrategy := [@lstring new !"SCHEDTABLE_NO_SYNC" !here];
    @luint64 precision := [@luint64 new !0L !here];
    cast [scheduletable ltgt_sync]:
    when == @ltgt_sync_true syncStrategyTrue do
      @lstring strategy := [syncStrategyTrue strategy];
      syncStrategy := [@lstring new !"SCHEDTABLE_".[strategy string]."_SYNC" ![strategy location]];
      precision := luint64OrError[![syncStrategyTrue precision] !"PRECISION"];
    else end cast;
    addLStringFieldValue !?fieldMap !"SYNCSTRATEGY" !syncStrategy;
    addLUnsignedFieldValue !?fieldMap !"PRECISION" !precision;
    
    @lstring scheduletableState := lstringWith[!""];
    @luint64 scheduletableDate := [@luint64 new !0L !here];
    cast [scheduletable autostart]:
    when == @sd_autostart_false  autostartFalse do
      scheduletableState := [@lstring new !"SCHEDULETABLE_STOPPED" ![autostartFalse location]];
    when == @sd_autostart_synchron autostartSynchron do
      scheduletableState := [@lstring new !"SCHEDULETABLE_AUTOSTART_SYNCHRON" ![autostartSynchron location]];
    when == @sd_autostart_relative autostartRelative do
      scheduletableState := [@lstring new !"SCHEDULETABLE_AUTOSTART_RELATIVE" ![autostartRelative location]];
      scheduletableDate := [autostartRelative offset];
    when == @sd_autostart_absolute autostartAbsolute do
      scheduletableState := [@lstring new !"SCHEDULETABLE_AUTOSTART_ABSOLUTE" ![autostartAbsolute location]];
      scheduletableDate := [autostartAbsolute value];
    else error lkey : "Internal error, unexpected type for AUTOSTART attribute of schedule table ".[lkey string];
    end cast;
    addLStringFieldValue !?fieldMap !"STATE" !scheduletableState;
    addLUnsignedFieldValue !?fieldMap !"DATE" !scheduletableDate;

    @uint64 length := 0L;
    cast [scheduletable length]:
    when == @uint64_class len do
      length := [len value];
      addUnsignedFieldValue !?fieldMap ![@lstring new !"LENGTH" ![len location]] !length;
    else error lkey: "internal, wrong type for LENGTH attribute";
    end cast;

    # add the finalize action (and expiry point if needed) to the
    # schedule table.
    @expiry_point_list expiryPoints := [scheduletable exp_points];
    @expiry_point_obj lastPoint;
    @uint64 lastOffset;
    [!?expiryPoints popGreatest ?lastOffset ?lastPoint];
    if lastOffset == length then
      # add the finalize action to the last expiry point
      @action_list actions := [lastPoint actions];
      actions += !10 ![@finalize_st_action new !here !lkey];
      [!?lastPoint setActions !actions];
    else
      # add a new expiry point for the finalize action
      @action_list finalizeExpiryPointActions [emptySortedList];
      finalizeExpiryPointActions += !10 ![@finalize_st_action new !here !lkey];
      @expiry_point_obj finalizeExpiryPoint :=
        [@expiry_point_obj new
          ![@lstring new !"" !here]
          ![@uint64_class new !here !length]
          ![@lstring new !"finalize" !here]
          ![@adjustable_void new !empty_lstring[] !here] 
          !finalizeExpiryPointActions
        ];
      expiryPoints += !length !finalizeExpiryPoint;
    end if;
    expiryPoints += !lastOffset !lastPoint;
    
    # set up the expiry points list
    @goilTemplateFieldMapList expiryPointsList [emptyList];
    @uint64 previousOffset := 0L;
    foreach expiryPoints do
      @goilTemplateFieldMap fieldMap [emptyMap];
      addUnsignedFieldValue !?fieldMap !lstringWith[!"ABSOLUTEOFFSET"] !off;
      addUnsignedFieldValue !?fieldMap !lstringWith[!"RELATIVEOFFSET"] !off-previousOffset;
#      addUnsignedFieldValue !?fieldMap !lstringWith[!"ACTIONCOUNT"] ![[[point actions] length] uint64];
      previousOffset := off;
      
      @goilTemplateFieldMapList actionsList [emptyList];
      foreach [point actions] do
        @goilTemplateFieldMap fieldMap [emptyMap];
        setAction !?fieldMap !actionobj;
        actionsList += !fieldMap;
      end foreach;
      addListFieldValue !?fieldMap !lstringWith[!"ACTIONS"] !actionsList;
      
      @luint64 maxAdvance := [@luint64 new !0L !here];
      @luint64 maxRetard := [@luint64 new !0L !here];
      cast [point adjust]:
      when == @adjustable_true adjustableExpiryPoint do
        maxAdvance := luint64OrError[![adjustableExpiryPoint max_advance] !"MAX_ADVANCE"];
        maxRetard := luint64OrError[![adjustableExpiryPoint max_retard] !"MAX_RETARD"];
      else end cast;
      addLUnsignedFieldValue !?fieldMap !"MAXRETARD" !maxRetard;
      addLUnsignedFieldValue !?fieldMap !"MAXADVANCE" !maxAdvance;
      
      expiryPointsList += !fieldMap;
    end foreach;
    addListFieldValue !?fieldMap !lstringWith[!"EXPIRYPOINTS"] !expiryPointsList;
    
    setAppRelatedAttributes !?fieldMap !cpu !appForObj !lkey;  

    scheduletablesList += !fieldMap;
  end foreach;
  addListValue !?cfg !lstringWith[!"SCHEDULETABLES"] !scheduletablesList;
end routine;

#
# set up the OS applications and trusted functions list
#
#
# computeBinaryVector generates a binary vector from its
# string representation
#
routine computeBinaryVector
  ??@string vec
  !@string res
  !@uint   byteCount
:
  # compute the number of bytes used
  byteCount := [vec length] / 8 ;
  if [vec length] mod 8 != 0 then byteCount++ ; end if ;

  @stringlist data [emptyList] ;
  @uint i := 0 ;
  @uint start := 0 ;

  # get each byte
  loop byteCount :
  while i < byteCount do
    @string byte := [[vec subString !start !8] reversedString] ;
    @uint bitPos := 0 ;
    @uint val := 0;
    # get each bit
    loop 8 :
    while bitPos < [byte length] do
      @char bit := [byte characterAtIndex !bitPos] ;
      val := val << 1 ;
      if bit == '1' then
        val++ ;
      end if ;
      bitPos++ ;
    end loop ;
    data += ![val string] ;
    i++ ;
    start := start + 8 ;
  end loop ;
  res := [@string componentsJoinedByString !data !", "] ;
end routine ;

routine computeVector
  ?!@string vector
  ??@lstring objectName
  ??@lstring applicationName
  ??@lstringlist ownedObjects
  ??@lstringlist accessingObjects
:
  if isInLstringlist[!ownedObjects !objectName] then
    vector .= "11";
  else
    vector .= "0";
    # compute the bit that flag access
    if isInLstringlist[!accessingObjects !applicationName] then
      vector .= "1";
    else
      vector .= "0";
    end if;
  end if;
end routine;
  

routine setOsapplicationsList
  ??@root_obj cpu
  ??@stringMap unused appForObj
  ?!@goilTemplateVariableMap cfg
:
  @goilTemplateFieldMapList osapplicationsList [emptyList];
  @stringset trustedFunctionSet [emptySet];
  @tasks_by_type allTaskList := orderedTaskList[!cpu];
  foreach [cpu applis] (@lstring applicationName @app_obj application) do
    @goilTemplateFieldMap fieldMap [emptyMap];
    addStringFieldValue !?fieldMap !lstringWith[!"NAME"] ![applicationName string];
    
    # add the restart task
    cast [application restart]:
    when == @string_class restartTask do
      addStringFieldValue !?fieldMap ![@lstring new !"RESTART" ![restartTask location]] ![restartTask value];
    else end cast ;
    # add the startup hook
    @bool hasStartup;
    cast [application startuphook]:
    when == @bool_class startup do
      hasStartup := [startup value];
    else
      hasStartup := false;
    end cast;
    addBoolFieldValue !?fieldMap ![@lstring new !"HASSTARTUPHOOK" ![[application startuphook] location]] !hasStartup;    
    # add the shutdown hook
    @bool hasShutdown;
    cast [application shutdownhook]:
    when == @bool_class shutdown do
      hasShutdown := [shutdown value];
    else
      hasShutdown := false;
    end cast;
    addBoolFieldValue !?fieldMap ![@lstring new !"HASSHUTDOWNHOOK" ![[application shutdownhook] location]] !hasShutdown;
    
    ##
    ## Compute the access vectors
    ##
    @string vector := "";
    @string binaryVector;
    @uint numberOfItems;
    # Compute the access vector for tasks
    @task_map allTasks := [cpu tasks];
    foreach allTaskList do
      @task_obj taskItem;
      [allTasks get !lstringWith[!name] ?taskItem];
      computeVector !?vector !lstringWith[!name] !applicationName ![[application tasks] allKeyList] ![taskItem acc_apps];
    end foreach;
    # Compute the access vector for ISRs
    foreach [cpu isrs] do
      computeVector !?vector !lkey !applicationName ![[application isrs] allKeyList] ![isr acc_apps];
    end foreach;
    # IDLE task can access to every OS-Application (for autostarting Schedule table...)
    vector .= "01";
    addStringFieldValue !?fieldMap !lstringWith[!"PROCESSACCESSVECTOR"] !vector;
    computeBinaryVector !vector ?binaryVector ?numberOfItems;
    addStringFieldValue !?fieldMap !lstringWith[!"PROCESSACCESSITEMS"] !binaryVector;
    addUnsignedFieldValue !?fieldMap !lstringWith[!"PROCESSACCESSNUM"] ![numberOfItems uint64];

    # Compute the access vector for alarms
    vector := "";
    foreach [cpu alarms] do
      computeVector !?vector !lkey !applicationName ![[application alarms] allKeyList] ![alarm acc_apps];
    end foreach;
    addStringFieldValue !?fieldMap !lstringWith[!"ALARMACCESSVECTOR"] !vector;
    computeBinaryVector !vector ?binaryVector ?numberOfItems;
    addStringFieldValue !?fieldMap !lstringWith[!"ALARMACCESSITEMS"] !binaryVector;
    addUnsignedFieldValue !?fieldMap !lstringWith[!"ALARMACCESSNUM"] ![numberOfItems uint64];

    # compute the access vector for resources
    vector := "";
    foreach [cpu resources] do
      computeVector !?vector !lkey !applicationName ![[application resources] allKeyList] ![resource acc_apps];
    end foreach;
    # add the res_scheduler
    vector .= "10" ;
    # TODO: do not add res_scheduler if it is not used.
    addStringFieldValue !?fieldMap !lstringWith[!"RESOURCEACCESSVECTOR"] !vector;
    computeBinaryVector !vector ?binaryVector ?numberOfItems;
    addStringFieldValue !?fieldMap !lstringWith[!"RESOURCEACCESSITEMS"] !binaryVector;
    addUnsignedFieldValue !?fieldMap !lstringWith[!"RESOURCEACCESSNUM"] ![numberOfItems uint64];

    # compute the access vector for schedule tables
    vector := "";
    foreach [cpu scheduletables] do
      computeVector !?vector !lkey !applicationName ![[application scheduletables] allKeyList] ![scheduletable acc_apps];
    end foreach;
    addStringFieldValue !?fieldMap !lstringWith[!"SCHEDULETABLEACCESSVECTOR"] !vector;    
    computeBinaryVector !vector ?binaryVector ?numberOfItems;
    addStringFieldValue !?fieldMap !lstringWith[!"SCHEDULETABLEACCESSITEMS"] !binaryVector;
    addUnsignedFieldValue !?fieldMap !lstringWith[!"SCHEDULETABLEACCESSNUM"] ![numberOfItems uint64];

    # compute the access vector for counters
    vector := "";
    foreach [cpu counters] do
      computeVector !?vector !lkey !applicationName ![[application counters] allKeyList] ![counter acc_apps];
    end foreach;
    addStringFieldValue !?fieldMap !lstringWith[!"COUNTERACCESSVECTOR"] !vector;
    computeBinaryVector !vector ?binaryVector ?numberOfItems;
    addStringFieldValue !?fieldMap !lstringWith[!"COUNTERACCESSITEMS"] !binaryVector;
    addUnsignedFieldValue !?fieldMap !lstringWith[!"COUNTERACCESSNUM"] ![numberOfItems uint64];

    # add the list of owned processes
    @goilTemplateFieldMapList procList [emptyList];
    @goilTemplateFieldMapList taskList [emptyList];
    @goilTemplateFieldMapList isrList [emptyList];
    foreach [application tasks] do
      @goilTemplateFieldMap taskFieldMap [emptyMap];
      addStringFieldValue !?taskFieldMap ![@lstring new !"NAME" ![lkey location]] ![lkey string];
      procList += !taskFieldMap;
      taskList += !taskFieldMap;
    end foreach;
    foreach [application isrs] do
      @goilTemplateFieldMap isrFieldMap [emptyMap];
      addStringFieldValue !?isrFieldMap ![@lstring new !"NAME" ![lkey location]] ![lkey string];
      @isr_obj isr;
      [[cpu isrs] get !lkey ?isr];
      cast [isr category]:
      when == @uint64_class cat do
        if [cat value] == 2L then
          # Only add ISR2 (not ISR1) in PROCESSES list of OSAPPLICATIONS list
          procList += !isrFieldMap;
        end if;
      else end cast;
      isrList += !isrFieldMap;
    end foreach;

    addListFieldValue !?fieldMap !lstringWith[!"PROCESSES"] !procList;
    addListFieldValue !?fieldMap !lstringWith[!"TASKS"] !taskList;
    addListFieldValue !?fieldMap !lstringWith[!"ISRS"] !isrList;
    
    # add the list of alarms
    @goilTemplateFieldMapList alarmList [emptyList];
    foreach [application alarms] do
      @goilTemplateFieldMap alarmFieldMap [emptyMap];
      addStringFieldValue !?alarmFieldMap ![@lstring new !"NAME" ![lkey location]] ![lkey string];
      alarmList += !alarmFieldMap;
    end foreach;
    addListFieldValue !?fieldMap !lstringWith[!"ALARMS"] !alarmList;
    
    # add the list of resources
    @goilTemplateFieldMapList resourcesList [emptyList];
    @goilTemplateFieldMapList regularResourcesList [emptyList];
    @goilTemplateFieldMapList internalResourcesList [emptyList];
    foreach [application resources] do
      @goilTemplateFieldMap resourceFieldMap [emptyMap];
      addStringFieldValue !?resourceFieldMap ![@lstring new !"NAME" ![lkey location]] ![lkey string];
      resourcesList += !resourceFieldMap;
      @resource_map allResources := [cpu resources];
      @resource_obj resource;
      [allResources get !lkey ?resource];
      cast [resource property]:
      when == @resource_property_internal_obj do
        internalResourcesList += !resourceFieldMap;
      else
        regularResourcesList += !resourceFieldMap;
      end cast;
    end foreach;
    addListFieldValue !?fieldMap !lstringWith[!"RESOURCES"] !resourcesList;
    addListFieldValue !?fieldMap !lstringWith[!"REGULARRESOURCES"] !regularResourcesList;
    addListFieldValue !?fieldMap !lstringWith[!"INTERNALRESOURCES"] !internalResourcesList;
    
    # add the list of schedule tables
    @goilTemplateFieldMapList scheduletableList [emptyList];
    foreach [application scheduletables] do
      @goilTemplateFieldMap scheduletableFieldMap [emptyMap];
      addStringFieldValue !?scheduletableFieldMap ![@lstring new !"NAME" ![lkey location]] ![lkey string];
      scheduletableList += !scheduletableFieldMap;
    end foreach;
    addListFieldValue !?fieldMap !lstringWith[!"SCHEDULETABLES"] !scheduletableList;
    
    # add the list of counters
    @goilTemplateFieldMapList counterList [emptyList];
    foreach [application counters] do
      @goilTemplateFieldMap counterFieldMap [emptyMap];
      addStringFieldValue !?counterFieldMap ![@lstring new !"NAME" ![lkey location]] ![lkey string];
      counterList += !counterFieldMap;
    end foreach;
    addListFieldValue !?fieldMap !lstringWith[!"COUNTERS"] !counterList;
    
    # add the list of messages
    @goilTemplateFieldMapList messageList [emptyList];
    foreach [application messages] do
      @goilTemplateFieldMap messageFieldMap [emptyMap];
      addStringFieldValue !?messageFieldMap ![@lstring new !"NAME" ![lkey location]] ![lkey string];
      messageList += !messageFieldMap;
    end foreach;
    addListFieldValue !?fieldMap !lstringWith[!"MESSAGES"] !messageList;
    
    osapplicationsList += !fieldMap;
    
    cast [application trusted]:
    when == @app_trusted_true t do
      foreach [t trusted_fcts] (@string trustedFunctionName) do
        trustedFunctionSet += !trustedFunctionName;
      end foreach;
    else end cast;
  end foreach;
  addListValue !?cfg !lstringWith[!"OSAPPLICATIONS"] !osapplicationsList;
  
  @goilTemplateFieldMapList trustedfunctionsList [emptyList];
  foreach trustedFunctionSet (@string trustedFunctionName) do
    @goilTemplateFieldMap fieldMap [emptyMap];
    addStringFieldValue !?fieldMap !lstringWith[!"NAME"] !trustedFunctionName;
    trustedfunctionsList += !fieldMap;
  end foreach;
  addListValue !?cfg !lstringWith[!"TRUSTEDFUNCTIONS"] !trustedfunctionsList;
end routine;

#
# Set up the informations to generate the ready list
#
routine setReadyList
  ??@root_obj cpu
  ??@prio_list readyList
  ?!@goilTemplateVariableMap cfg
:

  @uint prio := 0;
  @bool powerof2 := false;
  @ident_map config := [[cpu os] others];
  @goilTemplateFieldMapList fifoList [emptyList];
    
  # check if the POWER_OF_2_PRIORITY_QUEUE bool is declared
  if [config hasKey !"POWEROF2QUEUE"] then
    @basic_type pw;
    [config get ![@lstring new !"POWEROF2QUEUE" !here] ?pw];
    cast pw :
    when == @bool_class b do
      powerof2 := [b value];
    else
      error [pw location] : "POWEROF2QUEUE should be a boolean";
    end cast;
  end if;
  
  foreach readyList (@uint size) do
    @goilTemplateFieldMap fifoFieldMap [emptyMap];
    @uint maxSize;
    if powerof2 then
      maxSize := 1;
      loop 32 :
      while size > maxSize do
        maxSize := maxSize << 1;
      end loop;
    else
      maxSize := size;
    end if;
    addUnsignedFieldValue !?fifoFieldMap !lstringWith[!"SIZE"] ![maxSize uint64];
    fifoList += !fifoFieldMap;
  end foreach;
  addListValue !?cfg !lstringWith[!"READYLIST"] !fifoList;
end routine;

#
# set up the processes count:
# TASKCOUNT, BASICTASKCOUNT, EXTENDEDTASKCOUNT, PROCESSCOUNT,
# ISR1COUNT, ISR2COUNT and ISRCOUNT
#  
routine setProcessCount
  ??@root_obj cpu
  ?!@goilTemplateVariableMap cfg
:
  @uint64 taskCount := [[[cpu tasks] count] uint64];
  @uint64 isrCount := [[[cpu isrs] count] uint64];
  @uint64 extendedCount := 0L;
  foreach [cpu tasks] do
    if [[task events] length] > 0 then
      extendedCount++;
    end if;
  end foreach;
  @uint64 isr2Count := 0L;
  foreach [cpu isrs] do
    cast [isr category]:
    when == @uint64_class cat do
      if [cat value] == 2L then
        isr2Count++;
      end if;
    else
      error lkey: "missing CATEGORY attribute";
    end cast;
  end foreach;
  addUnsignedValue !?cfg ![@lstring new !"TASKCOUNT" !here] !taskCount;
  addUnsignedValue !?cfg ![@lstring new !"EXTENDEDTASKCOUNT" !here] !extendedCount;
  addUnsignedValue !?cfg ![@lstring new !"BASICTASKCOUNT" !here] !taskCount - extendedCount;
  addUnsignedValue !?cfg ![@lstring new !"PROCESSCOUNT" !here] !taskCount + isr2Count;
  addUnsignedValue !?cfg ![@lstring new !"ISRCOUNT" !here] !isrCount;
  addUnsignedValue !?cfg ![@lstring new !"ISR2COUNT" !here] !isr2Count;
  addUnsignedValue !?cfg ![@lstring new !"ISR1COUNT" !here] !isrCount - isr2Count;
end routine;

#
# set up the RESOURCECOUNT, REGULARRESOURCECOUNT and INTERNALRESOURCECOUNT
#
routine setResourceCount ??@root_obj cpu ?!@goilTemplateVariableMap cfg:
  addUnsignedValue !?cfg ![@lstring new !"RESOURCECOUNT" !here] ![[[cpu resources] count] uint64];
  @uint64 regularCount := 0L;
  @uint64 internalCount := 0L;
  foreach [cpu resources] do
    cast [resource property]:
    when == @resource_property_standard_obj do
      regularCount++;
    when == @resource_property_linked_obj do
      regularCount++;
    when == @resource_property_internal_obj do
      internalCount++;
    else
      error [[resource property] location] : "internal error, RESOURCEPROPERTY type is undefined";
    end cast;
  end foreach;
  addUnsignedValue !?cfg ![@lstring new !"REGULARRESOURCECOUNT" !here] !regularCount;
  addUnsignedValue !?cfg ![@lstring new !"INTERNALRESOURCECOUNT" !here] !internalCount;
end routine;

#
# set up the source files list
#
routine setSourceFileList ??@root_obj cpu ?!@goilTemplateVariableMap cfg:
  @goilTemplateFieldMapList sourceFileList [emptyList];
  foreach [[cpu os] app_src] (@lstring sourceFile) do
    @goilTemplateFieldMap sourceFileFieldMap [emptyMap];
    addStringFieldValue !?sourceFileFieldMap ![@lstring new !"FILE" ![sourceFile location]] ![sourceFile string];
    sourceFileList += !sourceFileFieldMap;
  end foreach;
  addListValue !?cfg !lstringWith[!"SOURCEFILES"] !sourceFileList;
end routine;

#
# set up the CFLAGS list
#
routine setCFlagsList ??@root_obj cpu ?!@goilTemplateVariableMap cfg:
  @goilTemplateFieldMapList cFlagsList [emptyList];
  foreach [[cpu os] cflags] (@lstring cFlag) do
    if stripString[![cFlag string]] != "" then
      @goilTemplateFieldMap cFlagFieldMap [emptyMap];
      addStringFieldValue !?cFlagFieldMap ![@lstring new !"CFLAG" ![cFlag location]] ![cFlag string];
      cFlagsList += !cFlagFieldMap;
    end if;
  end foreach;
  addListValue !?cfg !lstringWith[!"CFLAGS"] !cFlagsList;
end routine;

#
# set up the CPPFLAGS list
#
routine setCPPFlagsList ??@root_obj cpu ?!@goilTemplateVariableMap cfg:
  @goilTemplateFieldMapList cppFlagsList [emptyList];
  foreach [[cpu os] cppflags] (@lstring cppFlag) do
    if stripString[![cppFlag string]] != "" then
      @goilTemplateFieldMap cppFlagFieldMap [emptyMap];
      addStringFieldValue !?cppFlagFieldMap ![@lstring new !"CPPFLAG" ![cppFlag location]] ![cppFlag string];
      cppFlagsList += !cppFlagFieldMap;
    end if;
  end foreach;
  addListValue !?cfg !lstringWith[!"CPPFLAGS"] !cppFlagsList;
end routine;

#
# set up the ASFLAGS list
#
routine setAsFlagsList ??@root_obj cpu ?!@goilTemplateVariableMap cfg:
  @goilTemplateFieldMapList asFlagsList [emptyList];
  foreach [[cpu os] asflags] (@lstring asFlag) do
    if stripString[![asFlag string]] != "" then
      @goilTemplateFieldMap asFlagFieldMap [emptyMap];
      addStringFieldValue !?asFlagFieldMap ![@lstring new !"ASFLAG" ![asFlag location]] ![asFlag string];
      asFlagsList += !asFlagFieldMap;
    end if;
  end foreach;
  addListValue !?cfg !lstringWith[!"ASFLAGS"] !asFlagsList;
end routine;

#
# set up the LDFLAGS list
#
routine setLdFlagsList ??@root_obj cpu ?!@goilTemplateVariableMap cfg:
  @goilTemplateFieldMapList ldFlagsList [emptyList];
  foreach [[cpu os] ldflags] (@lstring ldFlag) do
    if stripString[![ldFlag string]] != "" then
      @goilTemplateFieldMap ldFlagFieldMap [emptyMap];
      addStringFieldValue !?ldFlagFieldMap ![@lstring new !"LDFLAG" ![ldFlag location]] ![ldFlag string];
      ldFlagsList += !ldFlagFieldMap;
    end if;
  end foreach;
  addListValue !?cfg !lstringWith[!"LDFLAGS"] !ldFlagsList;
end routine;

#
# set up the trace flag as long as related flags
#
routine setTraceFlag ??@root_obj cpu ?!@goilTemplateVariableMap cfg:
  cast [[cpu os] trace]:
  when == @trace noTrace do
    addBoolValue !?cfg ![@lstring new !"USETRACE" ![noTrace loc]] !false;
  when == @trace_off traceOff do
    addBoolValue !?cfg ![@lstring new !"USETRACE" ![traceOff loc]] !false;
  when == @trace_on traceOn do
    addBoolValue !?cfg ![@lstring new !"USETRACE" ![traceOn loc]] !true;
    addStringValue !?cfg ![@lstring new !"TRACEFORMAT" ![[traceOn form] location]] ![[traceOn form] string];
    #tasks
    if ([[[cpu tasks] count] uint64] > 0L) then
      addBoolValue !?cfg ![@lstring new !"TRACETASK" ![[traceOn trace_task] location]] !getBool[![traceOn trace_task] !true];
    else
      addBoolValue !?cfg ![@lstring new !"TRACETASK" ![[traceOn trace_task] location]] !getBool[![traceOn trace_task] !false];
    end if;
    #isrs
    if ([[[cpu isrs] count] uint64] > 0L) then
      addBoolValue !?cfg ![@lstring new !"TRACEISR" ![[traceOn trace_task] location]] !getBool[![traceOn trace_isr] !true];
    else
      addBoolValue !?cfg ![@lstring new !"TRACEISR" ![[traceOn trace_task] location]] !getBool[![traceOn trace_isr] !false];
    end if;
    #resources
    if ([[[cpu resources] count] uint64] > 0L) then
      addBoolValue !?cfg ![@lstring new !"TRACERESOURCE" ![[traceOn trace_task] location]] !getBool[![traceOn trace_resource] !true];
    else
      addBoolValue !?cfg ![@lstring new !"TRACERESOURCE" ![[traceOn trace_task] location]] !getBool[![traceOn trace_resource] !false];
    end if;
    #alarms
    if ([[[cpu alarms] count] uint64] > 0L) then
      addBoolValue !?cfg ![@lstring new !"TRACEALARM" ![[traceOn trace_task] location]] !getBool[![traceOn trace_alarm] !true];
    else
      addBoolValue !?cfg ![@lstring new !"TRACEALARM" ![[traceOn trace_task] location]] !getBool[![traceOn trace_alarm] !false];
    end if;
    addBoolValue !?cfg ![@lstring new !"TRACEUSEREVENT" ![[traceOn trace_task] location]] !getBool[![traceOn trace_user_event] !true];
    cast [traceOn meth]:
    when == @trace_file traceFile do
      addStringValue !?cfg ![@lstring new !"TRACEMETHOD" ![[traceOn meth] loc]] !"file";
      addStringValue !?cfg ![@lstring new !"TRACEFILE" ![[traceFile name] location]] ![[traceFile name] string];
    else end cast;
  else end cast;
end routine;

#
# set up the USELINKSCRIPT flag
#
routine setLinkScript ??@root_obj cpu ?!@goilTemplateVariableMap cfg:
  @string linkScriptName := link_script_name[![[cpu os] memmap]];
  @bool useLinkScript := (linkScriptName != "");
  addBoolValue !?cfg ![@lstring new !"USELINKSCRIPT" ![[[cpu os] memmap] location]] !useLinkScript;
  if useLinkScript then
    addStringValue !?cfg ![@lstring new !"LINKSCRIPT" ![[[cpu os] memmap] location]] !linkScriptName;
  end if;
end routine;

#
# set up the USEMEMORYMAPPING flag
#
routine setMemoryMapping ??@root_obj cpu ?!@goilTemplateVariableMap cfg:
  @bool useMemoryMapping := false;
  @bool useCompilerSettings := false;
  cast [[cpu os] memmap]:
  when == @memmap_false do
    useMemoryMapping := false;
    useCompilerSettings := false;
  when == @memmap_true trueMemmap do
    useMemoryMapping := true;
    @lstring compiler := [trueMemmap compiler];
    if [compiler string] != "" then
      useCompilerSettings := true;
      addLStringValue !?cfg !"COMPILER" !compiler;
    end if;
    @lstring assembler := [trueMemmap assembler];
    if [assembler string] != "" then
      addLStringValue !?cfg !"ASSEMBLER" !assembler;
    end if;
    cast [trueMemmap linker]:
    when == @no_linker do
    when == @yes_linker yesLinker do
      @lstring linker := [yesLinker linker];
      addStringValue !?cfg ![@lstring new !"LINKER" ![linker location]] ![linker string];
    else end cast;
  else end cast;
  addBoolValue !?cfg ![@lstring new !"USEMEMORYMAPPING" ![[[cpu os] memmap] location]] !useMemoryMapping;
  addBoolValue !?cfg ![@lstring new !"USECOMPILERSETTINGS" ![[[cpu os] memmap] location]] !useCompilerSettings;
end routine;

#
# set up the COMPILER string
#
routine setCompiler ??@root_obj cpu ?!@goilTemplateVariableMap cfg:
  @lstring compiler := [[cpu os] compiler];
  @string actualCompiler := "gcc";
  if [compiler string] != "" then actualCompiler := [compiler string]; end if;
  addStringValue !?cfg ![@lstring new !"COMPILEREXE" ![compiler location]] !actualCompiler;
end routine;

#
# set up the ASSEMBLER string
#
routine setAssembler ??@root_obj cpu ?!@goilTemplateVariableMap cfg:
  @lstring assembler := [[cpu os] assembler];
  @string actualAssembler := "as";
  if [assembler string] != "" then actualAssembler := [assembler string]; end if;
  addStringValue !?cfg ![@lstring new !"ASSEMBLEREXE" ![assembler location]] !actualAssembler;
end routine;

#
# set up the LINKER string
#
routine setLinker ??@root_obj cpu ?!@goilTemplateVariableMap cfg:
  @lstring linker := [[cpu os] linker];
  @string actualLinker := "gcc";
  if [linker string] != "" then actualLinker := [linker string]; end if;
  addStringValue !?cfg ![@lstring new !"LINKEREXE" ![linker location]] !actualLinker;
end routine;

#
# set up the TARGET, ARCH, CHIP and BOARD strings
#
routine setTarget ??@root_obj unused cpu ?!@goilTemplateVariableMap cfg:
  addStringValue !?cfg !lstringWith[!"TARGET"] ![option goil_options.target_platform value];
  addStringValue !?cfg !lstringWith[!"ARCH"] !arch[];
  addStringValue !?cfg !lstringWith[!"CHIP"] !chip[];
  addStringValue !?cfg !lstringWith[!"BOARD"] !board[];
end routine;

#
# set up the TEMPLATEPATH string
#
routine setTemplatePath ??@root_obj unused cpu ?!@goilTemplateVariableMap cfg:
  @string templatePath := [option goil_options.template_dir value];
  addStringValue !?cfg !lstringWith[!"TEMPLATEPATH"] !templatePath;
end routine;

#
# set up the TRAMPOLINEPATH string
#
routine setTrampolinePath ??@root_obj cpu ?!@goilTemplateVariableMap cfg:
  @lstring trampolinePath := [[cpu os] tpl_base_path];
  if [trampolinePath string] == "" then
    trampolinePath := [@lstring new !".." ![trampolinePath location]];
  end if;
  checkTrampolinePath !trampolinePath;
  addStringValue !?cfg ![@lstring new !"TRAMPOLINEPATH" ![trampolinePath location]] ![trampolinePath string];
end routine;

#
# set up the USESYSTEMCALL flag
#
routine setSystemCall ??@root_obj cpu ?!@goilTemplateVariableMap cfg:
  addBoolValue !?cfg ![@lstring new !"USESYSTEMCALL" ![[[cpu os] systemcall] location]] !getBool[![[cpu os] systemcall] !false];
end routine;

#
# set up the USEDEBUG flag
#
routine setDebug ??@root_obj cpu ?!@goilTemplateVariableMap cfg:
  addBoolValue !?cfg ![@lstring new !"USEDEBUG" ![[[cpu os] debug] location]] !getBool[![[cpu os] debug] !false];
end routine;

#
# set up the USEINTERRUPTTABLE flag
#
routine setUseInterruptTable ??@root_obj unused cpu ?!@goilTemplateVariableMap cfg:
  addBoolValue !?cfg !lstringWith[!"USEINTERRUPTTABLE"] ![option goil_options.posix_it value];
end routine;

#
# set up the build configuration
#
routine setBuildConfig ??@root_obj cpu ?!@goilTemplateVariableMap cfg:
  setSourceFileList !cpu !?cfg;
  setCFlagsList !cpu !?cfg;
  setCPPFlagsList !cpu !?cfg;
  setAsFlagsList !cpu !?cfg;
  setLdFlagsList !cpu !?cfg;
  setTraceFlag !cpu !?cfg;
  setLinkScript !cpu !?cfg;
  setMemoryMapping !cpu !?cfg;
  setCompiler !cpu !?cfg;
  setAssembler !cpu !?cfg;
  setLinker !cpu !?cfg;
  setTarget !cpu !?cfg;
  setTemplatePath !cpu !?cfg;
  setTrampolinePath !cpu !?cfg;
  setSystemCall !cpu !?cfg;
  setDebug !cpu !?cfg;
  setUseInterruptTable !cpu !?cfg;
end routine;

function useCommunication ??@root_obj cpu ->@bool useCom:
  useCom := false;
  @com comObject := [cpu com];
  if [comObject usecom] then
    useCom := true;
  else
    useCom := [[cpu messages] count] > 0    |
              [[cpu net_messages] count] > 0;
  end if;
end function;

#
# set up the USECOM flag and other COM related flags.
# USECOM is true if there is a COM object or if at least
# one object related to communication is declared
#
routine setUseCom ??@root_obj cpu ?!@goilTemplateVariableMap cfg:
  @bool useCom := useCommunication[!cpu];
  addBoolValue !?cfg ![@lstring new !"USECOM" !here] !useCom;  
  if useCom then
    @uint64 timeBaseInNanoseconds := 1_000_000L;
    @com comObject := [cpu com];
    cast [comObject timebase]:
    when == @float_class timeBase do
      timeBaseInNanoseconds := [([timeBase value] * 1_000_000_000.0) uint64];
    else end cast;
    
    addUnsignedValue !?cfg ![@lstring new !"COMTIMEBASE" ![[comObject timebase] location]] !timeBaseInNanoseconds;
    addBoolValue !?cfg ![@lstring new !"USECOMERRORHOOK" ![[comObject errorhook] location]] !getBool[![comObject errorhook] !false];
    addBoolValue !?cfg ![@lstring new !"USECOMGETSERVICEID" ![[comObject usegetserviceid] location]] !getBool[![comObject usegetserviceid] !false];
    addBoolValue !?cfg ![@lstring new !"USECOMPARAMETERACCESS" ![[comObject useparameteraccess] location]] !getBool[![comObject useparameteraccess] !false];
    addBoolValue !?cfg ![@lstring new !"USESTARTCOMEXTENSION" ![[comObject startcomextension] location]] !getBool[![comObject startcomextension] !false];

    @lstring comStatus := [comObject status];
    @bool comExtended := false;
    if [comStatus string] == "extended" then
      comExtended := true;
    end if;
    addBoolValue !?cfg ![@lstring new !"COMEXTENDED" ![comStatus location]] !comExtended;

  end if;
end routine;

#
# set up the EXTENDED flag
#
routine setExtended ??@root_obj cpu ?!@goilTemplateVariableMap cfg:
  @bool extended :=  ([[[cpu os] status] string] == "extended");
  addBoolValue !?cfg ![@lstring new !"EXTENDED" ![[[cpu os] status] location]] !extended;  
end routine;

routine scalabilityClass
  ??@root_obj cpu
  !@uint64 sc
  !@bool useTimingProtection
  !@bool useProtectionHook
:
  # if OSEK, we are in SC 0
  sc := 0L;
  useTimingProtection := false;
  useProtectionHook := false;
  @bool useGlobalTime := false;
  
  @bool useOSApplication := false;
  if [option goil_options.autosar_on value] then
    foreach [cpu tasks] do
      cast [task timing_prot]:
      when == @timing_prot_task do useTimingProtection := true;
      else end cast;
    end foreach;
      
    foreach [cpu isrs] do
      cast [isr timing_prot]:
      when == @timing_prot_isr do useTimingProtection := true;
      else end cast;
    end foreach;
    
    foreach [cpu scheduletables] do
      cast [scheduletable ltgt_sync]:
      when == @ltgt_sync_true do useGlobalTime := true;
      else end cast;
    end foreach;
    
    useOSApplication := [[cpu applis] count] > 0;
      
    cast [[cpu os] protectionhook]:
    when == @bool_class ph do
      useProtectionHook := [ph value];
    else end cast;
    
    
    
    # by default, we are in SC1
    sc := 1L;
    @string setSC := [[[cpu os] scalabilityclass] string];
    if setSC == "" | setSC == "AUTO" then

      # if protectionhook is set or
      # at least one task or ISR uses timing protection or
      # if global time sync is used then
      # we are in sc2
      if useTimingProtection | useProtectionHook | useGlobalTime then
        sc := 2L;
      end if;
      
      # Then check the memory protection and the availability
      # of an OS Application to see if the scalability class
      # must be increase by 2
      if memory_protection_on[![cpu os]] | [[cpu applis] count] > 0 then
        sc := sc + 2L;
      end if;
      
    else
      if setSC == "sc1" then
        # The user asks for scalability class 1
        # we check if other objects need a greater scalability class
        if useTimingProtection then
          if useOSApplication then
            sc := 4L;
            warning [[cpu os] scalabilityclass]: "SCALABILITYCLASS set to 4 because Timing Protection and OS Application are used";
          else
            sc := 2L;
            warning [[cpu os] scalabilityclass]: "SCALABILITYCLASS set to 2 because Timing Protection is used";
          end if;
        else
          if useOSApplication then
            sc := 3L;
            warning [[cpu os] scalabilityclass]: "SCALABILITYCLASS set to 3 because OS Application is used";
          else
            sc := 1L;
          end if;
        end if;
      elsif setSC == "sc2" then
        if useTimingProtection then
          if useOSApplication then
            sc := 4L;
            warning [[cpu os] scalabilityclass]: "SCALABILITYCLASS set to 4 because Timing Protection and OS Application are used";
          else
            sc := 2L;
          end if;
        else
          if useOSApplication then
            sc := 3L;
            warning [[cpu os] scalabilityclass]: "SCALABILITYCLASS set to 3 because OS Application is used";
          else
            sc := 2L;
          end if;
        end if;
      elsif setSC == "sc3" then
        if useTimingProtection then
          if useOSApplication then
            sc := 4L;
            warning [[cpu os] scalabilityclass]: "SCALABILITYCLASS set to 4 because Timing Protection and OS Application are used";
          else
            sc := 3L;
          end if;
        else
          sc := 3L;
        end if;
      elsif setSC == "sc4" then sc := 4L; end if;
    end if;
  end if;
end routine;

#
# set up the SCALABILITYCLASS flag (1, 2, 3 or 4)
# and USETIMINGPROTECTION flag (true or false)
#
routine setScalabilityClass ??@root_obj cpu ?!@goilTemplateVariableMap cfg:
  @uint64 sc;
  @bool useTimingProtection;
  @bool useProtectionHook;
  scalabilityClass !cpu ?sc ?useTimingProtection ?useProtectionHook;
  addUnsignedValue !?cfg !lstringWith[!"SCALABILITYCLASS"] !sc;  
  addBoolValue !?cfg !lstringWith[!"USETIMINGPROTECTION"] !useTimingProtection;  
  addBoolValue !?cfg !lstringWith[!"USEPROTECTIONHOOK"] !useProtectionHook;  
  addBoolValue !?cfg !lstringWith[!"USEMEMORYPROTECTION"] !memory_protection_on[![cpu os]];
  addBoolValue !?cfg !lstringWith[!"USEOSAPPLICATION"] !(sc == 3L | sc == 4L);
end routine;

#
# set up the hook and other flags
#
routine setUseHooks ??@root_obj cpu ?!@goilTemplateVariableMap cfg:
  addBoolValue !?cfg ![@lstring new !"USESTARTUPHOOK" ![[[cpu os] startuphook] location]] !getBool[![[cpu os] startuphook] !false];
  addBoolValue !?cfg ![@lstring new !"USESHUTDOWNHOOK" ![[[cpu os] shutdownhook] location]] !getBool[![[cpu os] shutdownhook] !false];
  addBoolValue !?cfg ![@lstring new !"USEERRORHOOK" ![[[cpu os] errorhook] location]] !getBool[![[cpu os] errorhook] !false];
  addBoolValue !?cfg ![@lstring new !"USEPRETASKHOOK" ![[[cpu os] pretaskhook] location]] !getBool[![[cpu os] pretaskhook] !false];
  addBoolValue !?cfg ![@lstring new !"USEPOSTTASKHOOK" ![[[cpu os] posttaskhook] location]] !getBool[![[cpu os] posttaskhook] !false];
  addBoolValue !?cfg ![@lstring new !"USEGETSERVICEID" ![[[cpu os] usegetserviceid] location]] !getBool[![[cpu os] usegetserviceid] !false];
  addBoolValue !?cfg ![@lstring new !"USEPARAMETERACCESS" ![[[cpu os] useparameteraccess] location]] !getBool[![[cpu os] useparameteraccess] !false];
  addBoolValue !?cfg ![@lstring new !"USERESSCHEDULER" ![[[cpu os] useresscheduler] location]] !getBool[![[cpu os] useresscheduler] !false];
  addBoolValue !?cfg ![@lstring new !"USESTACKMONITORING" ![[[cpu os] useresscheduler] location]] !getBool[![[cpu os] stackmonitoring] !false];
end routine;

routine setOsConfig ??@root_obj cpu ?!@goilTemplateVariableMap cfg:
  setExtended !cpu !?cfg;
  setUseCom !cpu !?cfg;
  setScalabilityClass !cpu !?cfg;
  setUseHooks !cpu !?cfg;
end routine;

#
# set the interrupt sources declared in target.cfg
#
routine setInterruptSources ??@config targetConfiguration ?!@goilTemplateVariableMap cfg:
  if [targetConfiguration hasKey!"it_sources"] then
    @basic_type interruptSources;
    [targetConfiguration get !lstringWith[!"it_sources"] ?interruptSources];
    cast interruptSources:
    when == @interrupts interrupts do
      addLUnsignedValue !?cfg !"ITSOURCESLENGTH" ![interrupts it_count];
      @goilTemplateFieldMapList interruptSourcesList [emptyList];
      foreach [interrupts it_sources] do
        @goilTemplateFieldMap fieldMap [emptyMap];
        addLStringFieldValue !?fieldMap !"NAME" !lkey;
        addUnsignedFieldValue !?fieldMap ![@lstring new !"NUMBER" ![value location]] !uint64OrError[!value !"interrupt source number"];
        interruptSourcesList += !fieldMap;
      end foreach;
      addListValue !?cfg !lstringWith[!"INTERRUPTSOURCES"] !interruptSourcesList;
    else end cast;
  end if;
end routine;


routine addDirectoryAndFile
  ?!@goilTemplateFieldMapList fileList
  ??@string directory
  ??@string file
:
  @goilTemplateFieldMap fieldMap [emptyMap];
  addStringFieldValue !?fieldMap !lstringWith[!"DIRECTORY"] !directory;
  addStringFieldValue !?fieldMap !lstringWith[!"FILE"] !file;
  fileList += !fieldMap;
end routine;

#
# Set environment related data
#
routine setEnvData ??@root_obj cpu ?!@goilTemplateVariableMap cfg:
  addStringValue !?cfg !lstringWith[!"OILFILENAME"] ![[@string stringWithSourceFilePath] lastPathComponent];
  addStringValue !?cfg ![@lstring new !"CPUNAME" !here] ![[cpu name] string];
  addStringValue !?cfg ![@lstring new !"TIMESTAMP" !here] ![@string stringWithCurrentDateTime];
  @lstring appName := applicationName[![cpu os]];
  addStringValue !?cfg ![@lstring new !"APPNAME" ![appName location]] ![appName string];
  addStringValue !?cfg !lstringWith[!"PROJECT"] ![projectName[] lastPathComponent];
  addStringValue !?cfg !lstringWith[!"PROJECTPATH"] !projectName[];
  addBoolValue !?cfg !lstringWith[!"USEBUILDFILE"] ![option goil_options.generate_makefile value];
  addBoolValue !?cfg !lstringWith[!"USELOGFILE"] ![option goil_options.generate_log value];
  #
  # Build a list of os, autosar and com files
  #
  @goilTemplateFieldMapList fileList [emptyList];
  addDirectoryAndFile !?fileList !"os" !"tpl_os_alarm_kernel.c";
  addDirectoryAndFile !?fileList !"os" !"tpl_os_event_kernel.c";
  addDirectoryAndFile !?fileList !"os" !"tpl_os_it_kernel.c";
  addDirectoryAndFile !?fileList !"os" !"tpl_os_rez_kernel.c";
  addDirectoryAndFile !?fileList !"os" !"tpl_os_task_kernel.c";
  addDirectoryAndFile !?fileList !"os" !"tpl_os_timeobj_kernel.c";
  addDirectoryAndFile !?fileList !"os" !"tpl_os_kernel.c";
  addDirectoryAndFile !?fileList !"os" !"tpl_os_action.c";
  addDirectoryAndFile !?fileList !"os" !"tpl_os_error.c";
  addDirectoryAndFile !?fileList !"os" !"tpl_os_dispatch_table.c";
  addDirectoryAndFile !?fileList !"os" !"tpl_os.c";
  if not getBool[![[cpu os] systemcall] !false] then
    addDirectoryAndFile !?fileList !"os" !"tpl_os_alarm.c";
    addDirectoryAndFile !?fileList !"os" !"tpl_os_event.c";
    addDirectoryAndFile !?fileList !"os" !"tpl_os_it.c";
    addDirectoryAndFile !?fileList !"os" !"tpl_os_rez.c";
    addDirectoryAndFile !?fileList !"os" !"tpl_os_task.c";
  end if;
  cast [[cpu os] trace]:
  when == @trace_on do
    addDirectoryAndFile !?fileList !"os" !"tpl_trace.c";
  else end cast;
  if useCommunication[!cpu] then
    addDirectoryAndFile !?fileList !"com" !"tpl_com_app_copy.c";
    addDirectoryAndFile !?fileList !"com" !"tpl_com_filtering.c";
    addDirectoryAndFile !?fileList !"com" !"tpl_com_filters.c";
    addDirectoryAndFile !?fileList !"com" !"tpl_com_internal_com.c";
    addDirectoryAndFile !?fileList !"com" !"tpl_com_external_com.c";
    addDirectoryAndFile !?fileList !"com" !"tpl_com_notification.c";
    addDirectoryAndFile !?fileList !"com" !"tpl_com_queue.c";
    addDirectoryAndFile !?fileList !"com" !"tpl_com_message_management.c";
    addDirectoryAndFile !?fileList !"com" !"tpl_com_errorhook.c";
  end if;
  if [option goil_options.autosar_on value] then
    addDirectoryAndFile !?fileList !"autosar" !"tpl_as_counter_kernel.c";
    addDirectoryAndFile !?fileList !"autosar" !"tpl_as_st_kernel.c";
    addDirectoryAndFile !?fileList !"autosar" !"tpl_as_isr_kernel.c";
    addDirectoryAndFile !?fileList !"autosar" !"tpl_as_stack_monitor.c";
    addDirectoryAndFile !?fileList !"autosar" !"tpl_as_timing_protec.c";
    addDirectoryAndFile !?fileList !"autosar" !"tpl_as_action.c";
    addDirectoryAndFile !?fileList !"autosar" !"tpl_as_protec_hook.c";
    @uint64 sc;
    scalabilityClass !cpu ?sc ?* ?*;
    if sc == 3L | sc == 4L then 
      addDirectoryAndFile !?fileList !"autosar" !"tpl_as_app_kernel.c";
      addDirectoryAndFile !?fileList !"autosar" !"tpl_as_trusted_fct_kernel.c";
    end if;
    if not getBool[![[cpu os] systemcall] !false] then
      addDirectoryAndFile !?fileList !"autosar" !"tpl_as_counter.c";
      addDirectoryAndFile !?fileList !"autosar" !"tpl_as_isr.c";
      addDirectoryAndFile !?fileList !"autosar" !"tpl_as_schedtable.c";
      if sc == 3L | sc == 4L then 
        addDirectoryAndFile !?fileList !"autosar" !"tpl_as_trusted_fct.c";
        addDirectoryAndFile !?fileList !"autosar" !"tpl_as_application.c";
      end if;
    end if;
  end if;
  addListValue !?cfg !lstringWith[!"TRAMPOLINESOURCEFILES"] !fileList;
end routine;

end semantics;
